* Utilisation du code
** Calcul de trajectoire

Afin de réaliser le calcul de trajectoire sur un modèle donné, il faut
suivre 4 étapes:

1. Compiler le code (avec ~cmake --build .~ depuis le dossier de build
   par exemple). La première compilation peut être longue car il faut
   compiler tous les modèles et le code
2. Initialiser le tableau des paramètres de trajectoires. Les valeurs
   possibles sont explicités dans la section sur les paramètres
3. Exécuter le code avec en paramètre le nom du fichier de modèle sans
   extension, soit [nom du fichier modèle].so (Exemple: si votre
   modèle est défini dans un fichier ~data_SimplePopGrowth.cpp~, alors
   il faut appeler ~./viabLabExe data_SimplePopGrowth~ ou
   ~./viabLabExe data_SimplePopGrowth.so~

Pour ensuite tracer ces trajectoires, utiliser le code contenu dans
~OUTPUT/plotViab.m~. Celui-ci se paramètre avec les valeurs contenues
en haut du code.

*** Exemple

Soit le modèle suivant contenu dans un fichier ~source/data/data_SimplePopGrowth.cpp~:

#+begin_src C++
  // Fonctions et import utiles (fonctions de math.h, string, et fonctions min, max et sign)
  #include "../include/utilities"

  // Bloc nécessaire à la compilation du modèle
  extern "C" {
      //------------------------------------------------------------------------------------------------------ 
      //  Model description header  for the problem SimplePopGrowth
      //  Edit this file to define your model parameters 
      //------------------------------------------------------------------------------------------------------ 
      string paramsFile = "SimplePopGrowth_params.json";
      //------------------------------------------------------------------------------------------------------ 
      // Dynamics definition  
      // Please fill the code of teh below function without changing it's signature  
      //------------------------------------------------------------------------------------------------------ 
      void dynamics(double * x, double * u, double * image)
      { 
          // programm here your dynamics function: 
          // x :     the input  state vector
          // u :     the input control vector 
          // image : the resulting state vector 
          image[0]=x[0]*x[1];
          image[1]=u[0];
      } 
      //------------------------------------------------------------------------------------------------------ 
      // Jacobian matrix of the dynamics. It will be used to estimate locally the Lipschitz constant  
      // Please fill the code of teh below function without changing it's signature  
      //------------------------------------------------------------------------------------------------------ 
      void jacobian(double * x, double * u , double ** jacob){
          // programm here the jacobian matrix of your dynamics function: 
          // x :     the input  state vector
          // u :     the input control vector 
          // jacob : the resulting matrix 
          jacob[0][0]=0.0;
          jacob[0][1]=0.0;
          jacob[1][0]=0.0;
          jacob[1][1]=0.0;
      } 
      //------------------------------------------------------------------------------------------------------ 
      // Local bound of the dynamics. Each element of the result vector is defined as max(over u) F_i(x,u)  
      // Please fill the code of teh below function without changing it's signature  
      //------------------------------------------------------------------------------------------------------ 
      void localDynBounds(double * x, double * bound){
          // programm here the bound of your dynamics function, maximized over the control: 
          // x :     the input  state vector
          // bound : the resulting vector 
          bound[0]=0.0;
          bound[1]=0.0;
      }
  }
#+end_src

Compiler le code avec ~cmake --build [Dossier du build]~ (Si ce n'est
pas déjà fait, exécuter ~cmake -S [Dossier source] -B [Dossier du build]~
avant pour la mise en place de la compilation).

Dans le dossier ~INPUT~ doit se trouver un fichier du nom de
~SimplePopGrowth_params.json~.
Pour que celui-ci soit utilisé pour paramétriser l'algorithme, il faut
que dans le modèle ~paramsFile~ vale le
nom de ce fichier. L'exemple donné ci-dessous doit
déjà se trouver dans le dossier ~INPUT~. Les éléments importants pour
le calcul d'une trajectoire sont les suivants:

#+begin_src javascript
  {
      "GRID_PARAMETERS": {
          // Dimension de l'espace d'état
          // (doit être égal à la taille de chaque tableau "INITIAL_POINT")
          "STATE_DIMENSION": 2,
      },
      // On peut tracer plusieurs trajectoires en une exécution en donnant plusieurs
      // paramètres de trajectoire dans la liste TRAJECTORY_PARAMETERS
      "TRAJECTORY_PARAMETERS": [
          // Les paramètres de la première trajectoire
          {
              // Trajectoire utilisant toujours le premier contrôle viable
              "TRAJECTORY_TYPE": "VD",
              // Point de départ de la trajectoire
              "INITIAL_POINT": [1.1, 0.9],
              // Durée de la trajectoire
              "TRAJECTORY_TIME_HORIZON": 15
          }
      ]
  }
#+end_src

Voici l'exemple complet contenu dans
~INPUT/SimplePopGrowth_params.json~ permettant de calculer le noyau de
viabilité et tracer avec le modèle d'accroissement de population une
[[Fonctionnalité de trajectoires "prudentes"][trajectoire "prudente"]] (le calcul peut être un peu long):

#+begin_src javascript
{
    "ALGORITHM_PARAMETERS": {
        "COMPUTE_MIN_TIME": false,
        "COMPUTE_VIABLE_SET": false,
        "GRID_REFINMENTS_NUMBER": 0,
        "INTERMEDIATE_SAVINGS": false,
        "ITERATION_STOP_LEVEL": 0,
        "LEVEL": 1,
        "PROJECTION_AXIS": [
            1,
            0
        ],
        "SAVE_BOUNDARY": true,
        "SAVE_PROJECTION": false,
        "SAVE_SLICE": false,
        "SAVE_SLICE_BOUND": false,
        "SAVE_SUBLEVEL": false,
        "SAVE_VIABSET_LIGHT": false,
        "SET_TYPE": "VIAB"
    },
    "CONTROL_PARAMETERS": {
        "CONTROL_DIMENSION": 1,
        "CONTROL_GRID_POINTS": [
            101
        ],
        "CONTROL_MAX_VALUES": [
            0.5
        ],
        "CONTROL_MIN_VALUES": [
            -0.5
        ]
    },
    "GRID_PARAMETERS": {
        "GRID_MAIN_DIR": 0,
        "GRID_METHOD": "BS",
        "LOWER_LIMIT_IS_NOT_CONSTRAINT": [
            0,
            0
        ],
        "OUTPUT_FILE_PREFIX": "SimplePopGrowth",
        "SLICE_DIRECTIONS": [
            0,
            0
        ],
        "SLICE_LEVELS": [
            1,
            1
        ],
        "SLICE_LEVELS_DISCRETE": [
            0,
            0
        ],
        "STATE_DIMENSION": 2,
        "STATE_GRID_POINTS": [
            1001,
            1001
        ],
        "STATE_MAX_VALUES": [
            3,
            2
        ],
        "STATE_MIN_VALUES": [
            0.2,
            -2
        ],
        "STATE_PERIODIC": [
            0,
            0
        ],
        "UPPER_LIMIT_IS_NOT_CONSTRAINT": [
            0,
            0
        ]
    },
    "SYSTEM_PARAMETERS": {
        "DYNAMICS_TYPE": "CC",
        "DYN_BOUND": 1.0,
        "DYN_BOUND_COMPUTE_METHOD": "NUMERICAL_CALC",
        "IS_TIMESTEP_GLOBAL": false,
        "LIPSCHITZ_CONSTANT": 1.0,
        "LIPSCHITZ_CONSTANT_COMPUTE_METHOD": "NUMERICAL_CALC",
        "TIME_DISCRETIZATION_SCHEME": "RK4"
    },
    "TRAJECTORY_PARAMETERS": [{
        "TRAJECTORY_TYPE": "CAUTIOUS",
        "INITIAL_POINT": [1.1, 0.9],
        "TRAJECTORY_TIME_HORIZON": 10
    }]
}
#+end_src

Le résultat est alors le suivant:

[[./img/cautious.jpg]]

** Paramètres du JSON

Les paramètres ont été classé en 4 catégories. La première catégories
sont les valeurs nommées. Les trois autres
catégories correspondent au type de valeurs pouvant être accepté pour
ce paramètre. Il sera certaines fois question de "tableau". Un tableau
est une suite de nombre d'une certaine taille séparée par une virgule
entouré de crochet ouvrant ou fermant (exemple: ~[3.14159, 2.71828,
1.61803]~, un tableau de taille 3). Si la
valeur par défaut indique ~y*[x]~, cela signifie que la valeur par
défaut du tableau vaut x pour chaque case du tableau et que le tableau
est de taille y. Un tableau, sauf indication du contraire, doit
toujours avoir la même taille que sa valeur par défaut.

*** Paramètres nommés

Voici un tableau récapitulatif des paramètres ayant des valeurs
nommées. Chaque paramètre peut soit être défini par son nom, soit par
le numéro associé à cette valeur entre parenthèses (tous deux dans la
colonne "Nom de l'énumération associé"). La valeur par défaut utilisée
si aucune valeur n'est indiquée est en gras (si elle existe). Une
valeur représentée par un nom doit être entourée de guillemets dans le
JSON (exemple : "VIAB" ).

| Nom du paramètre dans le JSON     | Clé de l'objet associé dans le JSON | Nom de l'énumération associée + valeurs                                             | Explication                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SET_TYPE                          | ALGORITHM_PARAMETERS                | SetType (macro SET_TYPE_VALUES dans Enums.h)                                        | Problème à résoudre représenté par l'ensemble de sortie. Cet ensemble est stocké dans le dossier OUTPUT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                   |                                     | *VIAB* (1)                                                                          | Calcul de noyau de viabilité (suffixe de nom de fichier en "-viab")                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                   |                                     | CAPT   (2)                                                                          | Calcul de bassin de capture (suffixe de nom de fichier en "-capt")                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|                                   |                                     | VIABG  (3)                                                                          | Calcul de noyau de viabilité garanti (suffixe de nom de fichier en "-viabG")                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| TRAJECTORY_TYPE                   | TRAJECTORY_PARAMETERS               | TypeTraj (macro TYPE_TRAJ_VALUES dans Enums.h)                                      | Type de trajectoire calculée si COMPUTE_TRAJECTORY vaut true                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                   |                                     | *VD* (1)                                                                            | Calcul de trajectoire viable par défaut (contrôles arbitraires)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                   |                                     | VL   (2)                                                                            | Calcul de trajectoire viable lourde. Le même contrôle est conservé jusqu'à ce que le contrôle nous amène dans un état où le prendre signifie sortir du noyau de viabilité.                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|                                   |                                     | OP   (3)                                                                            | Trajectoire optimale (uniquement pour une grille Micro-Macro) *à compléter*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                   |                                     | VMM  (4)                                                                            | Trajectoire micro-macro (uniquement pour une grille Micro-Macro) *à compléter*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                                   |                                     | VDI  (5)                                                                            | Trajectoire viable diversifiant le contrôle (uniquement pour une grille Micro-Macro) *à compléter**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                   |                                     | VG   (6)                                                                            | Trajectoire viable garantie *à compléter*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                   |                                     | STOCHASITC        (7)                                                               | Trajectoire aux contrôles choisis aléatoirement                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                   |                                     | WEIGHTED_CONTROLS (8)                                                               | Trajectoire avec contrôles préférés. La préférence utilisateur s'exprime à travers une fonction de pondération ~controlWeight(double *x, double *u, double normalizedTime)~                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                   |                                     | CAUTIOUS          (9)                                                               | Trajectoire évitant les bords (voir [[Fonctionnalité de trajectoires "prudentes"]]).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                   |                                     | WEIGHTED_CONTROLS_CAUTIOUS (10)                                                     | Identique à CAUTIOUS mais avec une fonction de pondération identique à WEIGHTED_CONTROLS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|                                   |                                     | Liste de stratégies (voir section sur [[Paramètres de la trajectoire par stratégies][les paramètres de trajectoire par stratégies]]) | Trajectoire calculé à chaque pas de temps par composition de différents algorithmes dits "stratégies" cherchant à décider du contrôle à prendre.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| TIME_DISCRETIZATION_SCHEME        | SYSTEM_PARAMETERS                   | TimeDiscretizationScheme (macro TIME_DISCRETIZATION_SCHEME_VALUES dans Enums.h)     | Méthode d'approximation de la trajectoire réelle                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                   |                                     | NO_DISCRETIZATION_SCHEME (0)                                                        | Aucune appoximation n'est réalisée, la trajectoire réelle est identique à la trajectoire discrète                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|                                   |                                     | *EL*  (1)                                                                           | Méthode d'Euler                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|                                   |                                     | RK2   (2)                                                                           | Méthode de Runge-Kutta d'ordre 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                   |                                     | RK4   (3)                                                                           | Méthode de Runge-Kutta d'ordre 4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| DYNAMICS_TYPE                     | SYSTEM_PARAMETERS                   | DynType (macro DYN_TYPE_VALUES dans Enums.h)                                        | Type de la dynamique                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                   |                                     | *CC*  (1)                                                                           | Continue en temps et en espace                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                                   |                                     | DC    (2)                                                                           | Temps discret, espace continu                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                   |                                     | DD    (3)                                                                           | Discrète en temps et en espace                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                                   |                                     | HD    (4)                                                                           | Dynamique "hybride"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| LIPSCHITZ_CONSTANT_COMPUTE_METHOD | SYSTEM_PARAMETERS                   | ComputeMethod (macro COMPUTE_METHOD_VALUES)                                         | Méthode de calcul de la constante de Lipschitz de la fonction de dynamique, utilisée pour déterminer le pas de temps                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                   |                                     | ANALYTICAL        (0)                                                               | La constante de Lipschitz vaudra toujours la valeur donnée pour LIPSCHITZ_CONSTANT possiblement majorée par COST_LIPSCHITZ_CONSTANT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                   |                                     | *ANALYTICAL_CALC* (1)                                                               | La constante de Lipschitz vaudra le coefficient de valeur absolue maximale de la jacobienne donnée par l'utilisateur en chaque point au travers de la fonction ~jacobian~ possiblement majorée par COST_LIPSCHITZ_CONSTANT                                                                                                                                                                                                                                                                                                                                                                                                                     |
|                                   |                                     | NUMERICAL_CALC    (2)                                                               | La constante de Lipschitz sera calculée pour chaque point                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| DYN_BOUND_COMPUTE_METHOD          | SYSTEM_PARAMETERS                   | ComputeMethod (macro COMPUTE_METHOD_VALUES)                                         | Méthode de calcul de la norme maximale de la fonction de dynamique                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                   |                                     | ANALYTICAL        (0)                                                               | La norme maximale de la dynamique est la valeur donnée pour DYN_BOUND, possiblement majorée par COST_BOUND_CONSTANT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                   |                                     | *ANALYTICAL_CALC* (1)                                                               | La norme maximale de la dynamique est la plus grande norme infinie renvoyé par localDynBounds parmi toutes les dimensions de l'espace, possiblement majorée par COST_BOUND_CONSTANT                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|                                   |                                     | NUMERICAL_CALC    (2)                                                               | La norme maximale de la dynamique est la valeur de plus grande norme infinie des vecteurs de dynamique pour les contrôles testés, possiblement majorée par COST_BOUND_CONSTANT                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| GRID_METHOD                       | GRID_PARAMETERS                     | GridMethod (macro GRID_METHOD_VALUES dans Enums.h)                                  | Méthode de stockage de la grille représentant la discrétisation du noyau de viabilité                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                   |                                     | *BS* (1)                                                                            | Représentation sous forme de Bit Set (tableau contenant des valeurs booléennes indiquant si la case se trouve dans le noyau)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                                   |                                     | MM   (2)                                                                            | Représentation sous forme de tableau de réels, dit "Micro Macro"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| FD_DYN_TYPE_VALUES                | non implémenté                      | FdDynType (macro FD_DYN_TYPE_VALUES dans Enums.h)                                   | Type de représentation de la fonction de la dynamique discrète (uniquement si DYN_TYPE vaut DD)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                   |                                     | FUNC  (1)                                                                           | Représentation sous la forme d'une fonction ~dynamics_fd~                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                   |                                     | RETRO (2)                                                                           | Représentation sous la forme d'un fichier donnant la valeur pour chaque paire (état, contrôle)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| TARGET_OR_DEPARTURE               | ALGORITHM_PARAMETERS (non utilisée) | TargetOrDeparture (macro TARGET_OR_DEPARTURE_VALUES dans Enums.h)                   | *à compléter*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                   |                                     | TARGET      (0)                                                                     | *à compléter*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                                   |                                     | *DEPARTURE* (1)                                                                     | *à compléter*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| BUBBLE_INTERPRETATION             | TRAJECTORY_PARAMETERS               | BubbleInterpretation (macro BUBBLE_INTERPRETATION_VALUES dans Enums.h)              | Indication sur le type de voisinage à considérer dans le calcul de bulle de trajectoire "prudente" (Uniquement utile si "TRAJECTORY_TYPE": "CAUTIOUS").                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                   |                                     | *MOORE*      (0)                                                                    | Les points dans la bulle sont les points de distance inférieure ou égale à la distance donnée pour BUBBLE_RADIUS (les distances de BUBBLE_RADIUS peuvent être différentes sur chaque dimension).                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                   |                                     | MOORE_PX     (1)                                                                    | Identique à MOORE mais les distances de BUBBLE_RADIUS seront supposées en points de grille plutôt qu'en distance de repère.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|                                   |                                     | EUCLIDEAN_PX (2)                                                                    | Les points dans la bulle sont les points contenu dans le cercle de BUBBLE_RADIUS. BUBBLE_RADIUS est considéré en pixels (toutes les distances doivent être identiques, sinon ELLIPTIC_PX sera supposé).                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                                   |                                     | ELLIPTIC_PX  (3)                                                                    | Les points de la bulle sont les points dans l'ellipsoïde ayant comme demi-axes les valeurs indiquées dans BUBBLE_RADIUS. Les valeurs de BUBBLE_RADIUS sont considérés en pixels.                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                   |                                     | CUSTOM       (4)                                                                    | Les points de la bulle sont les points contenu dans MOORE qui satisfont la contrainte utilisateur représenté par la fonction de modèle ~isValidNeighbor~. Les rayons de bulle en paramètre de ~isValidNeighbor~ sont exprimés en pixels. Il sont convertis des rayons donné en coordonnées réelle.                                                                                                                                                                                                                                                                                                                                             |
|                                   |                                     | CUSTOM_PX    (5)                                                                    | Identique à CUSTOM mais les distances de BUBBLE_RADIUS seront supposées en points de grille plutôt qu'en distance de repère.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| TYCHE_DISTRIBUTION                | TYCHE_PARAMETERS                    | TycheDistribution (macro TYCHE_DISTRIBUTION_VALUES dans Enums.h)                    | Indique la distribution des tychés (au sens du terme anglais de distribution (loi) de probabilité) dans le cas d'une trajectoire tychastique                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                   |                                     | *UNIFORM*                         (0)                                               | Le tyché de cette coordonnée est est choisi selon une loi uniforme discrète sur leur ensemble de définition des tychés discrétisé en CONTROL_TY_GRID_POINTS[i] points.                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|                                   |                                     | CONSTANT                          (1)                                               | Le tyché de cette coordonnée est déterminisé et vaut en tout point de la trajectoire la valeur donnée dans le tableau "CONSTANT_TYCHE_VALUE"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                                   |                                     | CUSTOM_DETERMINED                 (2)                                               | Le tyché de cette coordonnée est choisi selon une fonction utilisateur ~tycheValue~. Celle-ci est supposée être une fonction "pure" (renvoyant toujours la même valeur pour des paramètres d'entrée identiques) et donc non stochastique.                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                   |                                     | CUMULATIVE_DISTRIBUTION           (3)                                               | Le tyché de cette coordonnée est choisi selon une fonction de répartition donnée par l'utilisateur. Sa signature est ~double cumulativeDistribution(double tycheValue, int coordIndex, const double *x, double t, int trajIndex)~ et doit renvoyer la valeur de la fonction de répartition prise en la valeur du tyché. Il est important que la somme des valeurs renvoyé par la fonction vale 1 (voir la section sur [[Distribution de probabilité][la distribution de probabilité]]).                                                                                                                                                                                         |
|                                   |                                     | CONSTANT_CUMULATIVE_DISTRIBUTION  (4)                                               | Identique à CUMULATIVE_DISTRIBUTION mais la fonction n'est appelée qu'une seule fois en début de trajectoire (la distribution sera supposée indépendante de l'état ou du temps).                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|                                   |                                     | PROBABILITY_DENSITY               (5)                                               | Le tyché de cette coordonnée est choisi selon une fonction de densité/de masse donnée par l'utilisateur. Sa signature est ~double probabilityDensity(double tycheValue, int coordIndex, const double *x, double t, int trajIndex)~ et doit renvoyer la valeur de la fonction de densité prise en la valeur du tyché. Il est à noter que si la fonction de répartition peut être calculée aussi efficacement que la fonction de densité que donner la fonction de répartition est algorithmiquement plus rapide. Il est important que la somme des valeurs renvoyé par la fonction vale 1 (voir la section sur [[Distribution de probabilité][la distribution de probabilité]]). |
|                                   |                                     | CONSTANT_PROBABILITY_DENSITY      (6)                                               | Identique à PROBABILITY_DENSITY mais la fonction n'est appelée qu'une seule fois en début de trajectoire (la distribution sera supposée indépendante de l'état ou du temps).                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-----------------------------------+-------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

*** Paramètres booléen

Ce qui est appelé "paramètre booléen" est un paramètre qui peut
seulement prendre comme valeur ~true~ ou ~false~. Il existe plusieurs
synonymes pour ~true~ et ~false~. Les valeurs 0, "0" (entre gillemets,
chaîne de caractères), "false" (chaîne de caractères) sont identiques
à ~false~. Les valeurs 1, "1" (chaine de caractères) et "true" pour
~true~.

| Nom du paramètre dans le JSON                                     | Par défaut              | Clé de l'objet associé dans le JSON | Explication                                                                                                                                                                                                                                                                                                                                                 |
|-------------------------------------------------------------------+-------------------------+-------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| COMPUTE_MIN_TIME                                                  | false                   | ALGORITHM_PARAMETERS                | Le problème à résoudre est un problème de temps minimal.                                                                                                                                                                                                                                                                                                    |
| COMPUTE_VIABLE_SET                                                | true                    | ALGORITHM_PARAMETERS                | Doit-on calculer le noyau de viabilité ? Si la variable est fausse alors le résultat sera cherché dans le fichier OUTPUT/[OUTPUT_FILE_PREFIX]-viab.dat                                                                                                                                                                                                      |
| INTERMEDIATE_SAVINGS                                              | false                   | ALGORITHM_PARAMETERS                | Doit-on sauvegarder tous les rafinements de grille ? Le nombre de rafinement est dicté par NB_GRID_REFINEMENTS. Implémenté uniquement dans ViabiBitSet. Les fichiers de sauvegarde auront la forme "../OUTPUT/[OUTPUT_FILE_PREFIX]-viab-[i].dat" avec i l'indice de la boucle de rafinement (partant de 0)                                                  |
| SAVE_BOUNDARY                                                     | false                   | ALGORITHM_PARAMETERS                | Doit-on sauvegarder les bords du noyau de viabilité dans une fichier ? Le nom du fichier sera OUTPUT/[OUTPUT_FILE_PREFIX]-viab-bound.dat                                                                                                                                                                                                                    |
| SAVE_PROJECTION                                                   | false                   | ALGORITHM_PARAMETERS                | *TODO*                                                                                                                                                                                                                                                                                                                                                      |
| SAVE_SLICE                                                        | false                   | ALGORITHM_PARAMETERS                | Doit-on sauvegarder la coupe choisie à l'aide de SLICE_DIRECTIONS et SLICE_LEVELS dans un fichier ? Le nom du fichier sera OUTPUT/[OUTPUT_FILE_PREFIX]-Slice.dat                                                                                                                                                                                            |
| SAVE_SLICE_BOUND                                                  | false                   | ALGORITHM_PARAMETERS                | Doit-on sauvegarder le bord du noyau de viabilité coupé dans un fichier ?  Le nom du fichier sera OUTPUT/[OUTPUT_FILE_PREFIX]-SliceBound.dat                                                                                                                                                                                                                |
| SAVE_SUBLEVEL                                                     | false                   | ALGORITHM_PARAMETERS                | Uniquement pour un GRID_METHOD "MM", indique si l'on doit enregistrer la fonction de valeur de la grille. Le nom du fichier sera OUTPUT/[OUTPUT_FILE_PREFIX]-subLevel.dat                                                                                                                                                                                   |
| SAVE_VIABSET_LIGHT                                                | false                   | ALGORITHM_PARAMETERS                | Indique si l'on doit sauvegarder uniquement les points de grille qui sont dans le noyau de viabilité                                                                                                                                                                                                                                                        |
| STATE_PERIODIC (tableau de taille STATE_DIMENSION)                | STATE_DIMENSION*[false] | GRID_PARAMETERS                     | Indique pour chaque axe si la dimension de l'espace est périodique, c'est-à-dire, si dépasser le bord STATE_MAX_VALUES ou STATE_MIN_VALUES implique boucler sur le côté opposé de l'espace sur cette dimension                                                                                                                                              |
| UPPER_LIMIT_IS_NOT_CONSTRAINT (tableau de taille STATE_DIMENSION) | STATE_DIMENSION*[false] | GRID_PARAMETERS                     | Indique pour chaque axe si STATE_MAX_VALUES n'est pas une contrainte du problème de viabilité mais une contrainte imposée sur la taille de l'espace d'états (si une case d'indice i vaut vrai, un point peut appartenir au noyau de viabilité même s'il sa coordonnée en i est supérieur à STATE_MAX_VALUES si UPPER_LIMIT_IS_NOT_CONSTRAINT en i est true) |
| LOWER_LIMIT_IS_NOT_CONSTRAINT (tableau de taille STATE_DIMENSION) | STATE_DIMENSION*[false] | GRID_PARAMETERS                     | Indique pour chaque axe si STATE_MIN_VALUES n'est pas une contrainte du problème de viabilité mais une contrainte imposée sur la taille de l'espace d'états (si une case d'indice i vaut vrai, un point peut appartenir au noyau de viabilité même s'il sa coordonnée en i est inférieur à STATE_MIN_VALUES si LOWER_LIMIT_IS_NOT_CONSTRAINT en i est true) |
| SLICE_DIRECTIONS                                                  | STATE_DIMENSION*[false] | GRID_PARAMETERS                     | Indique que l'on souhaite regarder une coupe du noyau en "fixant" les valeurs des dimensions dont ce tableau est à true. La valeur fixe peut être choisie à l'aide de SLICE_LEVELS)                                                                                                                                                                         |
| IS_TIMESTEP_GLOBAL (non implémenté)                               | false                   | SYSTEM_PARAMETERS                   | *TODO*                                                                                                                                                                                                                                                                                                                                                      |
| SAVE_PICKING_STRATEGY                                             | true                    | TRAJECTORY_PARAMETERS               | Si l'on utilise une trajectoire par stratégie, indique si l'on doit écrire dans les fichiers de sortie de la trajectoire le nom de la stratégie ayant choisi le contrôle.                                                                                                                                                                                   |
| ARE_STRATEGIES_GUARANTEED                                         | true                    | TRAJECTORY_PARAMETERS               | Dans le cas d'une trajectoire par stratégies tychastique, indique si l'on doit comprendre la liste de stratégies de TRAJECTORY_TYPE comme des stratégies renvoyant des contrôles garantis (viable pour tout tyché à chaque pas de temps) ou non garantis (viable pour le tyché courant choisi).                                                             |
|-------------------------------------------------------------------+-------------------------+-------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

*** Paramètres entiers

Ce qui est appelé "paramètre entier" est un paramètre pouvant prendre
comme valeur un nombre entier (sauf indication du contraire, positif
ou nul).

| Nom du paramètre dans le JSON     |                      Par défaut | Clé de l'objet associé dans le JSON | Explication                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|-----------------------------------+---------------------------------+-------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| GRID_REFINEMENTS_NUMBER           |                               0 | ALGORITHM_PARAMETERS                | Nombre de raffinement de grille souhaité. Un raffinement de grille est ici un doublement sur chaque axe du nombre de points de l'espace d'état. Permet d'approximer un noyau de viabilité avec maillage plus fin par affinage successifs de noyau plus grossier                                                                                                                                                                                                                                                                                                                                                                                                           |
| ITERATION_STOP_LEVEL              |                               0 | ALGORITHM_PARAMETERS                | Seuil du nombre de points enlevés dans une itération de l'algorithme du calcul du noyau de viabilité à partir duquel on arrête l'algorithme (si cette valeur vaut 2 et que lors d'une itération on a enlevé 0, 1 ou 2 points de grille, l'algo s'arrête)                                                                                                                                                                                                                                                                                                                                                                                                                  |
| CONTROL_DIMENSION                 |                               1 | CONTROL_PARAMETERS                  | Dimension de l'espace des contrôles                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| CONTROL_TYCHASTIC_DIMENSION       |                               1 | CONTROL_PARAMETERS                  | Dimension de l'espace des contrôles tychastiques                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| CONTROL_GRID_POINTS               |           CONTROL_DIMENSION*[1] | CONTROL_PARAMETERS                  | Nombre de coordonnées de contrôles différentes testés sur chaque dimension. Les contrôles testé seront ceux ayant pour valeur sur l'axe i CONTROL_MIN_VALUES[i] + i*(CONTROL_MAX_VALUES[i]-CONTROL_MIN_VALUES[i])/(CONTROL_GRID_POINTS[i] - 1) avec i allant de 0 à n-1 (les tableaux sont indicés à partir de 0)                                                                                                                                                                                                                                                                                                                                                         |
| CONTROL_TY_GRID_POINTS            | CONTROL_TYCHASTIC_DIMENSION*[1] | CONTROL_PARAMETERS                  | Nombre de coordonnées de contrôles tychastiques différentes testés sur chaque dimension. Les contrôles testé seront ceux ayant pour valeur sur l'axe i CONTROL_MIN_TY_VALUES[i] + i*(CONTROL_TY_MAX_VALUES[i]-CONTROL_TY_MIN_VALUES[i])/(CONTROL_TY_GRID_POINTS[i] - 1) avec i allant de 0 à n-1 (les tableaux sont indicés à partir de 0)                                                                                                                                                                                                                                                                                                                                |
| STATE_DIMENSION                   |                               1 | GRID_PARAMETERS                     | Dimension de l'espace d'états                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| GRID_MAIN_DIR                     |                               0 | GRID_PARAMETERS                     | Uniquement pour un GRID_METHOD "BS", indique l'indice de la dimension à partir de laquelle sera stocké le tableau de tableaux de bits. Le tableau contenant sera alors la dimension indiquée                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| STATE_GRID_POINTS                 |            STATE_DIMENSIONS*[2] | GRID_PARAMETERS                     | Nombre de coordonnées d'état différentes (de points de grille) sur chaque dimension. Les valeurs des points de grille sont donc les points de coordonnées pour chaque i valent STATE_MIN_VALUES[i] + i*(STATE_MAX_VALUES[i]-STATE_MIN_VALUES[i])/(STATE_GRID_POINTS[i] - 1) avec i allant de 0 à n-1 (les tableaux sont indicés à partir de 0).                                                                                                                                                                                                                                                                                                                           |
| INITIAL_POINT_DISCRETE            |            STATE_DIMENSIONS*[0] | TRAJECTORY_PARAMETERS               | Points initiaux pour chaque trajectoire discrète ("DYNAMICS_TYPE": "DD"). Il s'agit d'un tableau de coordonnées de points (les coordonnées de points étant représentées par des tableaux de taille STATE_DIMENSION, donc un tableau de tableaux).                                                                                                                                                                                                                                                                                                                                                                                                                         |
| REAL_TIME_STEPS_PER_DISCRETE_STEP |                               1 | ALGORITHM_PARAMETERS                | Nombre d'itérations de calcul de la trajectoire réelle à l'aide du schéma numérique de résolution d'équations différentielles par pas de temps discret.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| SEED                              |                   Non spécifiée | TRAJECTORY_PARAMETERS               | Valeur entière ou tableau représentant la graine servant à initialiser le générateur de nombre pseudo-aléatoire pour les trajectoires tychastique. Une valeur simple (valeur dont le type n'est pas un tableau) sera interprétée identiquement à un tableau de taille 1 contenant cette valeur. Deux trajectoires tychastiques avec une graine identique seront parfaitement identiques. Si aucune seed n'est donnée, le générateur conserve l'état dans lequel il se trouve à la fin du calcul de la trajectoire précédente. Le générateur de nombres aléatoire utilisé pour la stratégie tychastique est différent de celui utilisé pour les trajectoires stochastiques |
| MAX_NB_REROLLS                    |                              10 | TYCHE_PARAMETERS                    | Nombre de tirage maximal pouvant être fait pour cette coordonnée de tyché en cas de non respect de la contrainte état-tyche ~constraintsXV_tych~. (voir la [[Gestion de la contrainte état-tyché dans TychePicker][gestion de la contrainte état-tyché]].                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|-----------------------------------+---------------------------------+-------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

**** Remarques sur SEED

Une conséquence de la non-modification de la seed est qu'une
sous-liste de la liste de paramètres de trajectoires dont la première
a une seed et les autres n'en on pas produira toujours les mêmes trajectoires.

Par exemple, si on a comme paramètre de trajectoire une liste de 6
trajectoires dont la première et la quatrième ont la même seed comme suit:

#+begin_src javascript
  "TRAJECTORY_PARAMETERS": [{"SEED": 42},
                            {},
                            {},
                            {"SEED": 42},
                            {},
                            {}]
#+end_src

alors les trajectoires 1 et 4 seront identiques, mais également les
trajectoires 2 et 5, et les trajectoires 3 et 6. Ceci permet de
n'avoir à donner qu'un seul seed à la première trajectoire pour
obtenir des trajectoires reproductibles. Je trouve que cette approche
n'est pas très intuitive et elle devrait possiblement être
retravaillée.

Il n'est pas possible de connaître la seed permettant de générer un
état arbitraire du générateur de nombre aléatoire utilisé, donc il
n'est pas possible d'obtenir la seed dans un fichier de sortie par
exemple. Si l'on veut des trajectoires reproductibles, il est
nécessaire de spécifier au moins une valeur de SEED. Il est cependant
possible de récuperer l'état du générateur et de lui réassigner plus
tard (à l'aide des opérateurs ~<<~ et ~>>~ de C++). Cette approche est
possiblement à considérer pour éviter l'approche contre-intuitive de
devoir donner une valeur de seed à la première trajectoire.

*** Paramètres réels

Ce qui est appelé "paramètre réel" est un paramètre pouvant prendre
comme valeur un nombre réel (le séparateur est le point "." et un
signe optionel peut être ajouté devant).

| Nom du paramètre dans le JSON         | Par défaut                             | Clé de l'objet associé dans le JSON | Explication                                                                                                                                                                                                                                                                                                                                      |
|---------------------------------------+----------------------------------------+-------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| LEVEL                                 | 0                                      | ALGORITHM_PARAMETERS                | Uniquement pour un GRID_METHOD "MM", seuil à partir duquel la valeur contenue dans la grille n'est pas conservé (considérée comme hors du noyau de viabilité). Ces valeurs ne sont conservées que si SAVE_SUBLEVEL vaut true                                                                                                                     |
| CONTROL_MIN_VALUES                    | CONTROL_DIMENSION*[0]                  | CONTROL_PARAMETERS                  | Coordonnée minimale des contrôles testés sur chaque dimension                                                                                                                                                                                                                                                                                    |
| CONTROL_MAX_VALUES                    | CONTROL_DIMENSION*[1]                  | CONTROL_PARAMETERS                  | Coordonnée maximale des contrôles testés sur chaque dimension                                                                                                                                                                                                                                                                                    |
| CONTROL_TY_MIN_VALUES                 | CONTROL_TYCHASTIC_DIMENSION*[0]        | CONTROL_PARAMETERS                  | Coordonnée minimale des contrôles tychastiques testées sur chaque dimension                                                                                                                                                                                                                                                                      |
| CONTROL_TY_MAX_VALUES                 | CONTROL_TYCHASTIC_DIMENSION*[1]        | CONTROL_PARAMETERS                  | Coordonnée maximale des contrôles tychastiques testées sur chaque dimension                                                                                                                                                                                                                                                                      |
| STATE_MIN_VALUES                      | STATE_DIMENSION*[0]                    | GRID_PARAMETERS                     | Coordonnée minimale de l'état sur chaque dimension                                                                                                                                                                                                                                                                                               |
| STATE_MAX_VALUES                      | STATE_DIMENSION*[1]                    | GRID_PARAMETERS                     | Coordonnée maximale de l'état sur chaque dimension                                                                                                                                                                                                                                                                                               |
| SLICE_LEVEL                           | STATE_DIMENSION*[0]                    | GRID_PARAMETERS                     | Pour chaque dimension fixée par la coupe, la valeur de la coordonnée qui nous intéresse. La valeur en i sera uniquement prise en compte si SLICE_DIRECTION[i] vaut true                                                                                                                                                                          |
| SLICE_LEVEL_DISCRETE                  | STATE_DIMENSION*[0]                    | GRID_PARAMETERS                     | Identique à SLICE_LEVELS mais pour un espace d'état discret.                                                                                                                                                                                                                                                                                     |
| TIME_HORIZON                          | 10                                     | SYSTEM_PARAMETERS                   | *TODO*                                                                                                                                                                                                                                                                                                                                           |
| TRAJECTORY_TIME_HORIZON               | 10                                     | TRAJECTORY_PARAMETERS               | Durée de la trajectoire calculée (le point initial est au temps t=0, le point final au temps t=TIME_HORIZON). L'unité est celle de la dynamique.                                                                                                                                                                                                 |
| LIPSCHITZ_CONSTANT                    | 1                                      | SYSTEM_PARAMETERS                   | Constante de Lipschitz de la fonction de dynamique. Celle-ci sera utilisée pour déterminer le pas de temps si LIPSCHITZ_CONSTANT_COMPUTE_METHOD vaut ANALYTICAL                                                                                                                                                                                  |
| COST_LIPSCHITZ_CONSTANT               | 1                                      | SYSTEM_PARAMETERS                   | *TODO*                                                                                                                                                                                                                                                                                                                                           |
| COST_BOUND_CONSTANT                   | 1                                      | SYSTEM_PARAMETERS                   | *TODO*                                                                                                                                                                                                                                                                                                                                           |
| DYN_BOUND                             | 1                                      | SYSTEM_PARAMETERS                   | Norme maximale de la dynamique. Celle-ci sera utilisée pour déterminer le pas de temps si DYN_BOUND_COMPUTE_METHOD vaut ANALYTICAL                                                                                                                                                                                                               |
| BUBBLE_RADIUS                         | 0.5 équivalent à STATE_DIMENSION*[0.5] | TRAJECTORY_PARAMETERS               | Rayon de la bulle utilisé pour un TRAJECTORY_TYPE valant CAUTIOUS. Il peut être donné comme un tableau ou un nombre (le donner comme un nombre est équivalent à donner un tableau où toutes les valeurs sont égales). Les valeurs sont interprétée soit en points de grilles, soit en distances réelles selon la valeur de BUBBLE_INTERPRETATION |
| INITIAL_POINT                         | STATE_DIMENSIONS*[0]                   | TRAJECTORY_PARAMETERS               | Points initiaux pour chaque trajectoire réelle. Il s'agit d'un tableau de coordonnées de points (les coordonnées de points étant représentées par des tableaux de taille STATE_DIMENSION, donc un tableau de tableaux)                                                                                                                           |
| INITIAL_CONTROL                       | CONTROL_DIMENSIONS*[0]                 | TRAJECTORY_PARAMETERS               | Contrôle de départ pris dans le cas d'une trajectoire lourde. Il s'agit d'un tableau de coordonnées de points (les coordonnées de points étant représentées par des tableaux de taille CONTROL_DIMENSION, donc un tableau de tableaux)                                                                                                           |
| INITIAL_VALUE                         | 0                                      | TRAJECTORY_PARAMETERS               | Valeur initiale prise dans le calcul d'une trajectoire Micro-Macro réelle pour chaque trajectoire                                                                                                                                                                                                                                                |
| INITIAL_VALUE_FD                      | 0                                      | TRAJECTORY_PARAMETERS               | Valeur initiale prise dans le calcul d'une trajectoire Micro-Macro discrète ("DYNAMICS_TYPE": "DD") pour chaque trajectoire                                                                                                                                                                                                                      |
| MAX_ANGLE_DEGREES / MAX_ANGLE_RADIANS | \pi/2 radians                          | TRAJECTORY_PARAMETERS               | Angle maximal que peuvent former trois points d'une trajectoire lissé par une stratégie "SMOOTH" (voir l'explication de la trajectoire [[smooth][SMOOTH]]). Le nom dans le JSON décide de l'unité de la valeur donnée en paramètre.                                                                                                                          |
| CONSTANT_TYCHE_VALUE                  | 0                                      | TYCHE_PARAMETERS                    | Si TYCHE_DISTRIBUTION est définie comme CONSTANT, ce paramètre donne la valeur du tyché constant en chaque point de la trajectoire                                                                                                                                                                                                               |
|---------------------------------------+----------------------------------------+-------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

*** Autres paramètres

| Nom du paramètre dans le JSON | Type                                                                                                          | Par défaut                                    | Clé de l'objet associé dans le JSON | Explication                                                                                                                                                         |
|-------------------------------+---------------------------------------------------------------------------------------------------------------+-----------------------------------------------+-------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| OUTPUT_FILE_PREFIX            | Chaîne de caractère                                                                                           | "Model-"                                      | GRID_PARAMETERS                     | Préfixe utilisé pour les fichiers de sortie du programme (par exemple, si aucun n'est donné, le fichier de données de grille vaudra "Model--grid-data.dat"          |
| TYCHE_PARAMETERS              | [Objet ayant des champs décrit comme ayant une "Clé de l'objet associé dans le JSON" valant TYCHE_PARAMETERS] | Valeurs par défaut des paramètres individuels | TRAJECTORY_PARAMETERS               | Tableau d'objets (valeurs entre accolades) de taille CONTROL_TYCHASTIC_DIMENSION représentant les paramètres des tychés dans le calcul de trajectoires tychastiques |
|-------------------------------+---------------------------------------------------------------------------------------------------------------+-----------------------------------------------+-------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------|

*** Paramètres de la trajectoire par stratégies

Une trajectoire par stratégies peut être définie comme une suite
d'algorithmes (nommées "stratégies") décidant du contrôle à
employer. On nommera par la suite l'algorithme décidant à l'aide de la
liste de stratégies du contrôle à prendre un "décideur" (dans le code,
un "ControlPicker").

On peut définir une trajectoire ainsi:

#+begin_src javascript
  "TRAJECTORY_TYPE": ["BUBBLE", "ORDER", "FIRST"]
#+end_src

Ici, on a une trajectoire équivalente à "WEIGHTED_CONTROL_CAUTIOUS"
cherchant à effectuer une stratégie de bulle utilisant pour simuler
un "décideur" ~["ORDER, "FIRST"]~.

"ORDER" ordonne simplement les indices de contrôles selon les
préférences utilisateur (indiqué par la fonction
~controlWeight~). "FIRST" choisit le premier contrôle de grille
viable selon ces préférences.

L'algorithme est donc ici le suivant: si la bulle ne touche pas le
bord du noyau de viabilité ou si la simulation du décideur
~["ORDER, "FIRST"]~,
n'atteint pas de bord de noyau de viabilité, alors on délègue la
responsabilité du choix à la stratégie suivante (ici "ORDER").
Si la simulation touche un bord, alors "BUBBLE" renvoie le
contrôle au bord choisi par le décideur ~["ORDER, "FIRST"]~
(c'est-à-dire, le premier contrôle viable au bord selon l'ordre des
préférences utilisateurs).

Un autre exemple, plus simple, est donné dans la section sur les [[Trajectoire par
stratégies][trajectoires par stratégies]]

Voici une liste des stratégies et les explications associées:

| Nom de la stratégie   | Explication                                                                                                                                                                                                                                                                                                        | Transmet le contrôle choisi par la stratégie précédente ? | Pas de temps différent de l'entrée ?                                                   | Délègue au suivant ?                                                                                                                                                             | Ordre des contrôles pris en compte ?                                                                              |
|-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------+----------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------|
| FIRST    (0)          | Cherche le successeur de grille selon le premier contrôle viable (selon ~preferedControlIndexes~), puis renvoie le premier contrôle et pas de temps rapprochant le plus possible le point réel au point de grille                                                                                                  | OUI                                                       | OUI (si le pas réel est différent du pas de grille)                                    | Si le point de grille n'a pas de successeur viable (très probablement une erreur)                                                                                                | OUI                                                                                                               |
| HEAVY    (1)          | Cherche à appliquer le même contrôle que l'itération précédente.                                                                                                                                                                                                                                                   | OUI                                                       | OUI (si le pas de temps donné ne marche pas, peut chercher à la diminuer)              | Si, peut importe le pas de temps choisi, la position de grille reste identique                                                                                                   | NON                                                                                                               |
| FIRST_ONLY (2)        | Cherche à appliquer le premier contrôle de grille viable (selon ~preferedControlIndexes~).                                                                                                                                                                                                                         | OUI                                                       | NON                                                                                    | Si le point de grille n'a pas de successeur viable                                                                                                                               | OUI                                                                                                               |
| SHUFFLE  (3)          | Réordonne de manière uniformément aléatoire les indices de contrôle (~preferedControlIndexes~).                                                                                                                                                                                                                    | OUI (toujours)                                            | NON                                                                                    | Toujours                                                                                                                                                                         | NON (modifié)                                                                                                     |
| SORT    (4)           | Réordonne les indices de contrôles (~preferedControlIndexes~) de manière décroissante selon la pondération de ~controlWeight~ .                                                                                                                                                                                    | OUI (toujours)                                            | NON                                                                                    | Toujours                                                                                                                                                                         | NON (modifié)                                                                                                     |
| RESET_ORDER (5)       | Réordonne les contrôles dans l'ordre initial du programme. Ceci permet de revenir à l'ordre de contrôle initial en cours d'application de la liste de stratégies.                                                                                                                                                  | OUI (toujours)                                            | NON                                                                                    | Toujours                                                                                                                                                                         | NON (modifié)                                                                                                     |
| CLOSEST  (6)          | Choisit le contrôle d'indice le plus proche selon l'ordre choisi par ~preferedControlIndexes~ viable.                                                                                                                                                                                                              | NON                                                       | NON                                                                                    | Si aucun contrôle viable n'est trouvé pour le pas de temps donné, ou si la stratégie précédente n'a pas renvoyé de contrôle                                                      | OUI                                                                                                               |
| PREFERED (7)          | Choisit le contrôle d'indice le plus proche selon l'ordre choisi par ~preferedControlindexes~ en essayant d'abord par indices croissant depuis le contrôle de la stratégie précédente (se rapprochant de la préférence utilisateur) puis par indices décroissants                                                  | NON                                                       | NON                                                                                    | Si aucun contrôle viable n'est trouvé pour le pas de temps donné, ou si la stratégie précédente n'a pas renvoyé de contrôle                                                      | OUI                                                                                                               |
| BUBBLE   (8)          | Si la bulle touche un bord, simule une trajectoire en appliquant à chaque pas de la simulation l'algorithme choisissant un contrôle selon le reste de la liste de stratégies (stratégies après la bulle). Si la simulation touche un bord, retourne le contrôle et le pas de temps du bord                         | OUI                                                       | OUI (si le pas de temps au bord est différent du pas de temps de la position courante) | Si la bulle ne touche pas le bord du noyau de viabilité, ou si la simulation n'atteint pas le bord du noyau de viabilité (sortie de bulle ou dépassement du nombre d'itérations) | NON (pas directement, mais possiblement pris en compte par les stratégies suivantes utilisées pour la simulation) |
| <<smooth>> SMOOTH (9) | Choisit le contrôle le plus proche du contrôle passé en entrée respectant la condition donné que trois points consécutifs de la trajectoire réelle ne doivent pas former un angle dépassant un "angle maximal". Cet angle maximal est donné par le paramètres JSON "MAX_ANGLE_RADIANS / MAX_ANGLE_DEGREES" du JSON | NON                                                       | NON                                                                                    | Si aucun contrôle ne respecte le critère de lisseur, ou si la stratégie précédente n'a pas renvoyé de contrôle                                                                   | NON                                                                                                               |
|-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------+----------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------|

*** Définition des paramètres de trajectoire et de tyché

Il est possible de spécifier une liste de paramètres de trajectoires
et de tychés de deux manières différentes. On prendra ici l'exemple
de la liste de paramètres de trajectoire, mais les listes paramètres
de tychés ont un fonctionnement identique (il suffira de remplacer les
occurences du mot "TRAJECTORY" par "TYCHE" dans le JSON et garder à
l'esprit que les listes paramètres de tychés devront toujours être
d'une taille égale à TYCHASTIC_CONTROL_DIMENSION).

Dans le cas de la trajectoire, l'attribut "TRAJECTORY_PARAMETERS" peut
être spécifié comme une liste (tableau dans le formalisme JSON) de
paramètres de trajectoires comme suit:

#+begin_src javascript
  {
      "GRID_PARAMETERS": {"STATE_DIMENSION": 2},
      /* ... */
      "TRAJECTORY_PARAMETERS":
      // Un tableau (entre crochets en JSON)
      [
          // d'objets (entre accolades)
          {
              "INITIAL_POINT": [10, 10],
              "TRAJECTORY_TYPE": ["FIRST"],
              "TRAJECTORY_TIME_HORIZON": 10,
          }, {
              "INITIAL_POINT": [10, 15],
              "TRAJECTORY_TYPE": ["FIRST"],
              "TRAJECTORY_TIME_HORIZON": 10,
          }, {
              "INITIAL_POINT": [10, 20],
              "TRAJECTORY_TYPE": ["FIRST"],
              "TRAJECTORY_TIME_HORIZON": 10,
          }
      ]
  }
#+end_src

Ici, on tracera 3 trajectoires de durée 10 avec une stratégie FIRST
avec 3 points de départ différents. Le problème de cette forme est que
si l'on souhaite tracer de nombreuses trajectoires avec un seul
paramètre qui diffère, le fichier de configuration JSON sera
inutiliement long pour répéter les mêmes paramètres communs.

Pour éviter cette répétition, il est possible d'écraser les paramètres
par défaut de la trajectoire en donnant à l'attribut
"TRAJECTORY_PARAMETERS" un objet (au lieu d'un tableau) avec deux
champs nommés "DEFAULT_VALUES" et "TRAJECTORY_SPECIFIC_VALUES". Le
champ "TRAJECTORY_SPECIFIC_VALUES" a comme attribut le même tableau
de paramètres de trajectoire que dans la forme précédente. Le champ
"DEFAULT_VALUES" prend comme valeur un seul objet paramètre de
trajectoire qui permet de définir les valeurs "par défaut" des
paramètres de trajectoires dans la liste des
"TRAJECTORY_SPECIFIC_VALUES". Par exemple, le JSON présenté plus haut
peut être écrit de la façon suivante en produisant un résultat
identique :

#+begin_src javascript
  {
      "GRID_PARAMETERS": {"STATE_DIMENSION": 2},
      /* ... */
      "TRAJECTORY_PARAMETERS":
      {
          "DEFAULT_VALUES":
          {
              "TRAJECTORY_TYPE": ["FIRST"],
              "TRAJECTORY_TIME_HORIZON": 10,
          },
          "TRAJECTORY_SPECIFIC_VALUES": [{
              "INITIAL_POINT": [10, 10],
          }, {
              "INITIAL_POINT": [10, 15],
          }, {
              "INITIAL_POINT": [10, 20],
          }]
      }
  }
#+end_src

ou encore, puisque les valeurs par défaut sont écrasée dès qu'une
valeur spécifique est donnée :

#+begin_src javascript
  {
      "GRID_PARAMETERS": {"STATE_DIMENSION": 2},
      /* ... */
      "TRAJECTORY_PARAMETERS":
      {
          "DEFAULT_VALUES":
          {
              "INITIAL_POINT": [10, 10],
              "TRAJECTORY_TYPE": ["FIRST"],
              "TRAJECTORY_TIME_HORIZON": 10,
          },
          "TRAJECTORY_SPECIFIC_VALUES": [{
          }, {
              "INITIAL_POINT": [10, 15],
          }, {
              "INITIAL_POINT": [10, 20],
          }]
      }
  }
#+end_src

Avec cette écriture, il est plus simple de tracer, par exemple, 10
trajectoires stochastiques partant du même point pour observer le
résultat:

#+begin_src javascript
  {
      "GRID_PARAMETERS": {"STATE_DIMENSION": 2},
      /* ... */
      "TRAJECTORY_PARAMETERS":
      {
          "DEFAULT_VALUES":
          {
              "INITIAL_POINT": [10, 10],
              "TRAJECTORY_TYPE": ["STOCHASTIC"],
              "TRAJECTORY_TIME_HORIZON": 10,
          },
          "TRAJECTORY_SPECIFIC_VALUES": [{}, {}, {}, {}, {},
                                         {}, {}, {}, {}, {}]
      }
  }
#+end_src

Pour l'instant le nombre de trajectoires est entièrement défini par la
longueur de la liste "TRAJECTORY_SPECIFIC_VALUES". Il faut donc
ajouter autant de paire d'accolades qu'il y a de trajectoires, mais il
est possible qu'une version future ajoute un paramtère
"NB_TRAJECTORIES" pour éviter cela (ceci n'est pas un problème de
"TYCHE_PARAMETERS", puisque le nombre de paramètres tychastique est
égal à "CONTROL_TYCHASTIC_DIMENSION", si la liste des paramètres
tychastiques est trop courte, elle sera remplie de valeurs par
défaut, si elle est trop longue, les paramètres superflus seront
ignorés).

** Fichiers de sortie
*** Fichier de grille

Le fichier de grille est un fichier permettant de connaître les
dimensions et paramètres de la grille et ainsi pouvoir lire les autres
fichiers. Dans le cas de l'exemple de SimplePopGrowth a le format
suivant (sans les lignes avec commentaires après un #):

#+begin_example
# Dimension de l'espace d'états (STATE_DIMENSION)
2     
# Valeurs minimales des coordonnées d'un état (STATE_MIN_VALUES)
# Il y a une valeur par STATE_DIMENSION
0.2   
-2
# Valeurs maximales des coordonnées d'un état (STATE_MAX_VALUES)
# Il y a une valeur par STATE_DIMENSION
3
2
# Nombre de points de grille par dimension (STATE_GRID_POINTS)
1001
1001
# Indice des dimensions à conserver pour la coupe (SLICE_DIRS)
0
0
# Valeur souhaitée pour la dimension fixée (SLICE_VALUES)
1
1

#+end_example

*** Fichiers de noyau de viabilité
**** Fichier de noyau complet

Un fichier de noyau de viabilité est un fichier se terminant en
~-viab.dat~ contenant des lignes
représentant les coordonnées des points de grille et leur appartenance
au noyau. Chaque ligne contient ~STATE_DIMENSION~ coordonées de points
de grille séparés par des espaces et en dernier une valeur.

La signification de la valeur en fin de ligne diffère selon
~GRID_METHOD~.

Si ~GRID_METHOD~ vaut "BS" (BitSet), la dernière valeur
vaut 1.0 si le point est dans le noyau de viabilité et 0.0 sinon. Il
est possible de ne pas écrire les valeurs pas contenues dans le noyau
en mettant ~SAVE_VIABSET_LIGHT~ à true, dans quel cas le fichier ne
contiendra que les lignes se terminant par 1.0.

Si ~GRID_METHOD~ vaut
~MM~ (MicroMacro), la dernière valeur indique la valeur de la grille
en cette position. La dernière valeur vaudra alors ~PLUS_INF~ (constante
du programme valant 10^{15}) si la valeur n'est pas contenue dans le
noyau et une valeur strictement inférieure si elle appartient au
noyau. Tout comme pour un méthode ~BS~, il est possible de ne
conserver que les lignes contenues dans le noyau de viabilité.

**** Fichier de bord de noyau

Un fichier de bord de noyau de viabilité est un fichier se terminant
en ~-viab-bound.dat~. Ce fichier contient les
points représentant les bords du noyau de viabilité. Ces points sont
écrits sous forme de ~STATE_DIMENSION~ coordonnées séparées par des
espaces. Il y a un point par ligne.

*** Fichiers de trajectoire

Les fichiers de trajectoire fonctionnent par paires. Chaque fichier de
trajectoire "réelle" se terminant en ~-traj-[i].dat~, avec ~i~ un
entier, est accompagné d'un fichier de trajectoire discrète en
~traj-[i]-Discrete.dat~.

Le fichier de trajectoire réelle est un ensemble de lignes
représentant chacune un état, un temps (durée) depuis le début de la
trajectoire et un contrôle. Chaque état est représenté par
~STATE_DIMENSION~ coordonnées et chaque contrôle par
~CONTROL_DIMENSION~ coordonnées.

Si jamais une trajectoire par
stratégie est utilisée, et que le paramètre de trajectoire
~SAVE_PICKING_STRATEGY~ n'est pas ~false~, la dernière colonne sera
une liste de stratégies de la forme
"NOM_STRATEGIE_1(indice_dans_liste_de_stratégies),NOM_STRATEGIE_2(indice_dans_liste_de_stratégies),...NOM_STRATEGIE_n(indice_dans_liste_de_stratégies)".
Chaque stratégie à l'intérieur de cette liste est alors une stratégie
ayant contribué au choix (modifié la valeur) du contrôle retourné.

Une ligne est donc composée de:
1. ~STATE_DIMENSION~ coordonnées séparées par des espaces représentant
   un état.
2. Une durée depuis le début de la trajectoire.
3. ~CONTROL_DIMENSION~ coordonnées séparées par des espaces
   représentant un contrôle.
4. Optionellement, une liste de stratégies séparées par des virgules
   (,) au format "NOM(indice)", avec "indice" un entier correspondant
   à l'indice dans la liste des stratégies et "NOM" le nom de la
   stratégie ayant cet indice dans le JSON.

Pour un schéma numérique donnée (Euler, Runge-Kutta d'ordre 2,
Runge-Kutta d'ordre 4), il devrait être possible de retrouver la
trajectoire obtenue à l'aide de la dynamique, notée \Phi(x, u) avec
x l'état et u le contrôle (à un éventuel warning du programme
près). On note x_n l'état sur la ligne n, t_n la durée en n et
u_n le contrôle en n.

Pour la méthode d'Euler, on a par exemple que:

x_{n+1} = x_{n} + (t_{n+1} - t_{n})\Phi(x_n, u_n)

* Changements apportés
** CMakeLists.txt

Passage à c++17 pour permettre les init-statements dans une condition
~if~, sans quoi il y a des warnings à la compilation. Ajout du flag
~-Wno-unused~ car polluant la sortie standard de compilation.

Ajout de ~-Wextra~ qui a pu détecter des comparaisons toujours vraies
ou toujours fausses dans ~Grid.cpp~, ~GridBitSet.cpp~.

Ma solution à ce dernier problème a été de convertir les expressions
de la manière suivante:

#+begin_src C
  // Version initiale (toujours fausse car posX + ... sera converti
  // en une expression du type de posX, qui est unsigned).
  if (posX + indicesDecalSub[k] < 0)
  // Étape 1 (équivalent mais toujours un warning)
  if (posX < -indicesDecalSub[k])
  // Étape 2 (ce que devait retranscrire la condition)
  if (indicesDecalSub[k] < 0 && posX < ((unsigned long long int) -indicesDecalSub[k]))      
#+end_src

Éventuellement une version plus lisible qui effectue correctement le
test pourrait être proposée, mais je n'ai pas trouvé mieux

Il a également pu détecter un appel ~system("pause")~ dans ~ViabiBitSet.cpp~
qui n'a pas été commenté, car utiliser ~system~ provoque un warning quand sa
valeur de retour n'est pas utilisée.

De plus, il a détecté deux valeurs ~minValCell~ potentiellement
non-initialisée dans ~ViabiMictoMacroDiscrete::ViabKerGarantiFunc~  et
~ViabiMicroMacroDiscrete::viabKerValFunc~.La valeur peut ne pas être
initialisée si la valeur courante (~currentVal~) est supérieure ou
égale à ~PLUS_INF~. Cela ne devrait jamais se produire
dans notre programme, mais le compilateur ne peut pas le savoir, donc
j'ai initialisé les valeurs à ~PLUS_INF~.

** Fonctionnalité de contrôles aléatoire
*** Quoi

L'utilisateur peut spécifier qu'il veut que les contrôles soient
choisis aléatoirement (au lieu d'arbitrairement) pour un
ViabiBitSet. Pour cela, dans les paramètres de contrôles, il doit
indiquer dans le JSON un ~TRAJECTORY_TYPE~ valant ~STOCHASTIC~
(ou valant 7).

*** Comment

Si le type de trajectoire vaut ~STOCHASTIC~, alors, dans le fichier
~initParams.h~ le pointeur de fonction ~sortIndexes~ de ~systemParams~
sera initialisé par la fonction ~shuffleControlIndexes~ (sinon par une
fonction par défaut ~noSort~) qui réalise une permutation des
contrôles passés en paramètre.

~sortControlIndexes~ est une fonction appelée lors du choix de successeur discret
(une seule fois par choix, pas par successeur possible) et trie un
tableau alloué dans ~SysDyn~ nommé ~preferedControlIndexes~ (ceci
évite de modifier le tableau ~controlCoords~). Un getter est associé à
ce tableau. Le tri peut être réalisé par ~sortPreferedControlIndexes~ qui
renvoie le tableau trié en fonction de l'état courant.

Le fichier ~TrajectoryHelpers.cpp~ a également été créé, mais il est
possible que les fonctions définies dans celui-ci changent de fichier
d'implémentation.

*** Pourquoi

Le flag dans le JSON permet à l'utilisateur de simplement activer et
désactiver cette fonctionalité.

L'utilisation d'un tableau ~preferedControlIndexes~ avec une fonction qui
réalise le tri permet une modification minime du code déjà existant
(en plus d'appeler ~getControlCoords~, il suffit d'appeler
~sortPreferedControlIndexes~ et indicer le tableau ~controlCoords~ par
les valeurs de ~preferedControlIndexes~).

Les méthodes ont été séparées en 2 car
~sortPreferedControlIndexes~ peut modifier l'ordre du tableau, et n'est donc
pas un simple "getter". Si l'on ne veut retrouver l'ordre déjà
calculé (ou ne pas recalculer l'ordre à chaque fois), il suffit d'appeler
~getPreferedControlIndexes~.

** Fonctionnalité d'ordre sur les contrôles
*** Quoi

L'utilisateur peut spécifier une fonction ~controlWeight~ de
pondération sur les contrôles. Lorsque celle-ci est définie,
l'utilisateur peut spécifier un type de trajectoire
~WEIGHTED_CONTROLS~. Dans ce cas, les contrôles
seront choisi dans l'ordre défini par la pondération sur les
contrôles. Le contrôle avec la plus grande pondération sera donc
essayé avant les autres.

*** Comment

La pondération est utilisé par la fonction ~sortControIndexesByWeight~ qui
prend en argument un tableau de contrôles et qui le trie selon cette
pondération. Cette fonction est affecté à l'attribut ~sortControls~ de
~systemParams~. Le reste fonctionne comme pour les contrôles aléatoires.

*** Pourquoi

Les objectifs sont les mêmes que
pour les contrôles aléatoires, l'implémentation étant pensée pour
pouvoir ajouter cette fonctionnalité facilement (on affecte simplement
le pointeur de fonction utilisé pour trier le tableau de
~preferedControlIndexes~ à la fonction de tri ~sortControlIndexesByWeight~).

** Utilisation d'enumérations
*** Quoi

Modification du format du JSON et suppression de ~#define~ dans
~defs.h~ pour rendre les noms des paramètres du programme plus
explicite avec une enumération.

Le mode de reconstruction de la trajectoire par exemple se choisit à
partir d'une enum:

#+begin_src C++
  enum TimeDiscretizationScheme : unsigned char {
      NO_DISCRETIZATION_SCHEME = 0,
      EL  = 1,
      RK2 = 2,
      RK4 = 3,
  };
#+end_src

Le JSON peut ainsi être rendu plus explicite:

#+begin_src js
  "SYSTEM_PARAMETERS": {
      "TIME_DISCRETIZATION_SCHEME": "EL",
  }  
#+end_src

L'option de spécifier un entier au lieu d'une chaîne de caractère a été conservée.

*** Comment

Les enums sont définies dans le fichier ~Enums.h~. Comme elles ont
toutes les mêmes fonctionalités (conversion depuis et vers une chaîne
de caractères, conversion depuis et vers un nombre, conversion visible
par le property_tree de boost), des macros ont été utilisée pour
automatiser la création d'une enumération.

Pour créer l'enum suivante:

#+begin_src C
  enum Vehicule {
      VOITURE = 0,
      BUS     = 1,
      VELO    = 2,
      BATEAU  = 3,
  };
#+end_src

Il faut utiliser la syntaxe suivante:

#+begin_src C
    #define VEHICULE_VALUES(FUNCTION)           \
        FUNCTION(VOITURE, 0)                    \
        FUNCTION(BUS, 1)                        \
        FUNCTION(VELO, 2)                       \
        FUNCTION(BATEAU, 3)                     \

  DEFINE_ENUM(Vehicule, VEHICULE_VALUES)
#+end_src

~DEFINE_ENUM~ est une macro qui, à partir du nom de type voulu pour
l'enum (ici Vehicule) et la macro ~VEHICULE_VALUES~ crée:
- L'enumération ci-dessus.
- Une fonction ~toString~ pour l'énumération.
- Un traducteur boost pour l'enumération, traduisant le contenu du
  JSON en enum et vice-versa.

*** Pourquoi

L'utilisation d'enumérations permet d'avoir des paramètres plus explicites
dans le JSON, et dans le code. Ils assurent aussi un typage des
valeurs énumérées qui permet d'éviter des erreurs de programmation
(lors de la modification, j'ai remarqué que dans SysDyn.cpp,
~COMPUTE_LC~ et ~COMPUTE_MF~ avaient été assigné des valeurs ~double~,
alors qu'il sont entiers par exemple).

L'utilisation de macro pour générer les enums permet:
- D'éviter de devoir écrire des traducteurs identiques pour chaque
  énumération
- De s'assurer que les valeurs traitées par les traducteurs soient
  toujours valides, peut importe si on change le nom ou les valeurs
  des types énumérés

** Création du fichier Params.h

La création de ces fichiers permet de ne pas avoir à recompiler une
grande partie du code à chaque changement dans les structures de
paramètres dans le cas de ~Params.h~

** Ajout de getIndicesDecal

Pour une cohérence avec ~getIndicesDecalCells~ et parce que j'en avais
besoin dans une autre méthode, j'ai ajouté ce getter

** Ajout de méthodes getSetName et saveViableSets dans ViabiBitSet

Ajout de méthodes permettant de réduire la duplication de code lié à
la sauvegarde des trajectoires.

** Fonctionnalité de trajectoires "prudentes"
*** Quoi

Un algorithme ~computeCautiousTrajectory~ a été
ajouté. Cet algorithme vérifie à chaque pas de temps autour du point
courant s'il y a un bord à une distance donnée. On appelle cette zone
où l'on cherche un bord une "bulle" dans notre algorithme. Le
fonctionnement schématique est le suivant:

#+begin_example
Paramètres: position initiale,
            durée de la trajectoire,
            tableau indicé des controles possibles,
            bulle d'un rayon et de forme donné par l'utilisateur

Tant qu'il nous reste du temps:
    S'il y a un bord touchant la bulle:
        T <- (1) Trajectoire simulée jusqu'à être arrivé à un bord
                 ou être sorti de la bulle
        Si T ne se termine pas sur le bord
            Appliquer une itération de l'algorithme par défaut
        Sinon:
            ub <- Indice du contrôle viable appliqué au bord s'il existe,
                  sinon celui appliqué l'itération précédente
            u  <- (2) Premier indice de contrôle viable au point courant
                      en partant de ub jusqu'au contrôle choisi par
                      l'algorithme par défaut                      
            Appliquer le controle d'indice u au point courrant
        Fin Si
    Sinon:
        Appliquer une itération de l'algorithme par défaut
    Fin Si
Fin Tant Que
#+end_example

Cet algorithme se paramètre dans le JSON en mettant ~TRAJECTORY_TYPE~
à ~CAUTIOUS~ (ou à 9) et en précisant un paramètre de taille de bulle
"BUBBLE_RADIUS" positif. Ce paramètre correspond à la distance par
rapport au centre des côtés de la bulle (la bulle est un hypercube
dont tous les côtés mesurent 2xBUBBLE_RADIUS).

L'itération de l'algorithme par défaut est réalisé dans
~computeViableTrajectoryIteration~.

L'algorithme (1) est réalisé par ~findPositionAtBorder~ qui réalise
schématiquement l'algorithme suivant:

#+begin_example
Paramètres: position courante
Copier les informations de la position courante dans une copie Cp

Tant que l'on est dans la bulle
      et que l'on est pas sur un bord
      et que l'on a pas dépassé un nombre maximal d'itérations:

      Cp <- Appliquer une itération de l'algorithme par défaut sur Cp
Fin Tant Que

Retourner Cp et un booléen indiquant si on est sur le bord
#+end_example

L'algorithme (2) est réalisé par
~applyClosestToControl~. Celui-ci trouve le premier contrôle
viable à appliquer à la position courante. Les contrôles utilisés sont
celui du bord, puis ceux se rapprochant jusqu'à celui préféré par
l'utilisateur en position courante dans l'ordre total imposé par
~controlWeight~ (ou un ordre par défaut dans le cas de ~CAUTIOUS~).
L'algorithme est le suivant:

#+begin_example
Paramètres : contrôle viable au bord ub, position courante
u <- ub

Tant que u existe et que u n'est pas viable dans la position courante
    u <- contrôle croissant dans la préférence utilisateur
Fin Tant que

u <- ub si u n'existe pas

Tant que u existe et que u n'est pas viable dans la position courante
    u <- contrôle décroissant dans la préférence utilisateur
Fin Tant Que

Retourner u
#+end_example

En pratique, u "n'existe pas" signifie que dans l'ordre de parcours
imposé par le Tant Que, on a essayé tous les contrôles. Dans le
premier Tant que, u "n'existe pas" si on a dépassé dans l'ordre imposé
le contrôle minimal et dans le deuxième Tant que, si on a dépassé le
contrôle maximal.

*** Comment

Le code de l'itération de l'algorithme par défaut a été isolé dans une
fonction ~computeViableTrajectoryIteration~. Une méthode ~isOnBorder~ a
été créée pour savoir si une bulle touche un bord. Une méthode
~findPositionAtBorder~ permet de simuler la trajectoire jusqu'à un
bord éventuel.

~isOnBorder~ considère qu'un point est un bord si un de ces voisins
dans le voisinage de von Neumann du point est en dehors du noyau de
viabilité. Le voisinage de von Neumann est constitué des cellules
adjacentes à un point. En dimension 2, ceci correspond au point
adjacents horizontalement et verticalement. La figure ci-dessous
illustre le voisinage de von Neumann en 2 dimensions. Les
ronds sont les points appartenant au voisinage de von Neumann de la
croix:

|   |   |   |   |   |
|   |   | O |   |   |
|   | O | X | O |   |
|   |   | O |   |   |
|   |   |   |   |   |

Pour savoir si un contrôle donné est viable, une méthode
~isViableControl~ et ~checkKernelRelation~ ont également été
ajoutées. ~isViableControl~ permet de vérifier si un contrôle est
viable. Pour cela, il vérifie si le contrôle satisfait les contraintes
utilisateur sur le contrôle en la position actuelle et ensuite si la
position d'arrivée est dans le noyau de viabilité à l'aide de
~checkKernelRelation~.

*** Pourquoi

Les trajectoires viables ont une propriété de [[https://core.ac.uk/download/pdf/82026632.pdf][Semi-perméabilité]]
signifiant qu'une trajectoire viable (sous certaines conditions) a
tendance à rester "coincée" sur le bord du noyau de viabilité. Ceci
limite grandement les possibilités de trajectoire et coince souvent la
trajectoire sur un bord.

** Utilisation de librairies partagées
*** Quoi

Au lieu d'utiliser des .h pour les modèles qui doivent être inclus
dans ~data/ModelDataInclusion.h~, les modèles sont maintenant dans des
fichiers .cpp. Ceux-ci sont compilés séparément comme une "librairie
partagée" (shared object/dynamically loaded library selon le système
d'exploitation). L'exécutable
prend maintenant un argument supplémentaire en ligne de commande : le
nom du fichier de modèle à charger. Supposons que l'on ait un fichier
de modèle ~data/SimplePopGrowth.cpp~. Alors, pour utiliser ce modèle
avec la librairie, il faut appeler l'exécutable ainsi : ~./viabLabExe
SimplePopGrowth~ (ou sinon ~./viabLabExe SimplePopGrowth.so~,
l'argument étant le nom du fichier réel tel qu'il devrait être présent
dans le dossier de build).

*** Comment

Au lieu d'utiliser des ~__attribute__((weak))~ comme pouvait le faire
la librairie avant, toutes les fonction par défaut sont maintenant des
déclarations "fortes".

La librairie donnée en paramètre du programme est chargé à l'aide de
la fonction ~dlopen~ de l'en-tête ~<dlfcn.h>~ et les symboles sont
chargés avec ~dlsym~ dans ~initParams.h~. Si un symbole n'a pas été
trouvé, le symbole par défaut lui sera substitué.

**** Mise à jour des anciens modèles

Pour passer de l'ancienne version des modèles, il suffit de faire la
transformation suivante:

1. Modifier l'extension de fichier du modèle de .h à .cpp.
2. Entourer le code (*pas les instructions #include du début du
   programme*) d'un bloc commençant par ~extern "C"~ (explication
   après l'exemple).
3. Supprimer les gardiens de l'en-tête.
4. Supprimer d'éventuels ~inline~ dans les définitions de fonctions.

Par exemple, supposons qu'on ait un fichier ~data/viab2D.h~ suivant:

#+begin_src C++
  #ifndef VIAB2D_H_
  #define VIAB2D_H_

  #include "../include/ParametersManager.h"

  void dynamics(double * x, double *u, double * image)
  {

      image[0]=  x[0]*x[1];
      image[1]=  u[0];
  }

  inline void jacobian(double *x, double *u , double ** jacob)
  {
      jacob[0][0]=x[1];
      jacob[0][1]=x[0] ;
      jacob[1][0]=0.0;
      jacob[1][1]=0.0;
  }

  #endif /* VIAB2D_H_ */
#+end_src

Celui deviendrait alors:

#+begin_src C++
  // include en dehors du extern "C"
  #include "../include/ParametersManager.h"

  // bloc extern "C"
  extern "C" {
      void dynamics(double * x, double *u, double * image)
      {

          image[0]=  x[0]*x[1];
          image[1]=  u[0];
      }

      // Suppresion du inline
      void jacobian(double *x, double *u , double ** jacob)
      {
          jacob[0][0]=x[1];
          jacob[0][1]=x[0] ;
          jacob[1][0]=0.0;
          jacob[1][1]=0.0;
      }
  }
#+end_src

**** Parenthèse sur le ~extern "C"~

Le bloc ~extern "C"~ qui entoure les fonctions est nécessaire parce
que le code est compilé comme du C++. Le C++ possède un méchanisme de
polymorphisme de fonctions/méthodes qui engendre une difficulté : deux
fonctions de même nom (identifiant) ne peuvent pas exister
simulatement dans un exécutable/fichier objet. Le C++ réalise alors ce qui est
appelé du "name mangling" pour donner un identifiant unique à chaque
fonction. Cet identifiant ne possède pas de forme standard et c'est
donc le compilateur qui décide comment il doit être généré.

Le souci est que ~dlsym~ ne peut que charger des fonctions par leur
identifiant dans l'exécutable. Donc, depuis le code C++ utilisant
~dlsym~, il faut connaître l'identifiant dans le fichier
objet/exécutable.

Pour cela, la solution "standard" est d'entourer le code c++ d'un bloc
~extern "C"~ signifiant que le linkage du fichier se fait selon les
règles du C. Et puisque le C ne possède pas de méchanisme de
polymorphisme, le C peut (et doit selon le standard) utiliser dans ses
exécutable/fichiers objets comme identifiant le nom des fonctions
telles quelles sont nommées dans le code. On peut donc ainsi connaître
le nom de la fonction du modèle à l'exécution.

Le code contenu dans le bloc ~extern "C"~ a cependant quelques
restrictions:
- Il ne peut pas utiliser de fonctions polymorphiques
- Il ne peut pas utiliser de templates
- Les namespaces sont ignorés (conflits possibles donc)

D'autres restrictions existent, elles sont évoquées dans la [[https://isocpp.org/wiki/faq/mixing-c-and-cpp][FAQ C++]],
je ne les listerais pas toutes ici.

Les restrictions sont la raison pour laquelle je précise qu'il ne faut
pas entourer les ~#include~. La plupart des en-têtes c++ standard
utilisent sous une forme ou une autre un namespace ou des templates,
et ne fonctionneront donc pas avec le ~extern "C"~.

**** Compilation

En supposant que l'on utilise le compilateur g++, la compilation se
déroule de la manière suivante:

1. On compile tous les .cpp comme des fichiers .so (shared object
   linux). Ceci peut se faire avec la commande suivante : ~g++ -fPIC
   -shared libName.cpp -o libName.so~
2. On compile l'exécutable ~viabLabExe~ en liant à l'exécutable la
   librairie d'en-tête ~dlfnc.h~ (avec l'option ~-ldl~ sur linux) et
   on rend accessible aux fonctions chargées par les ~dlsym~ en
   ajoutant le flag correspondant (avec l'option ~-rdynamic~ avec g++)
   donnant la ligne de compilation suivante:
   ~g++ main.cpp -o main -ldl -rdynamic~

Le second point est important. Si on oublie de préciser le flag
~-rdynamic~, les fonctions chargées n'auront pas accès au fonction de
l'exécutable ~./viabLabExe~ (en particulier, certains modèles ayant
besoin de ~ParametersManager~ n'auraient pas accès à ses méthodes).

Le fichier CMake a changé de version minimale requise. Dans la version
initiale de la librairie, [[https://cmake.org/cmake/help/latest/policy/CMP0065.html][CMake ajoutait le flag par
défaut]]. Maintenant que la mise à jour a été faite, il faut ajouter
~set(CMAKE_EXECUTABLE_ENABLE_EXPORTS 1)~ au début du fichier
~CMakeLists.txt~ pour que le flag soit correctement ajouté (ce qui a
pu mener à des erreurs dans certaines plus anciennes versions du code).

*** Pourquoi

La prise en main de la librairie est assez difficile tel quel et
l'utilisation de librairies rend son utilisation plus simple (plus
besoin de modifier un fichier .h dans data, ni de recompiler à chaque
changement de modèle). Les modèles sont compilés séparement du
programme principal ce qui permet de les modifier et d'en ajouter sans
recompiler le reste de la librairie. On peut aussi en parallèle avoir
plusieurs "copies" du même modèle où l'on modifierait qu'un seul
paramètre et il n'y aurait pas besoin de recompiler l'exécutable
lorsqu'on veut changer de modèle.

** Possibilité d'ajouter plus de points continus par point discret

Un attribut a été ajouté au ALGORITHM_PARAMETERS du JSON nommé
REAL_TIME_STEPS_PER_DISCRETE_STEP. Celui-ci permet de contrôler le
nombre de points utilisé dans le calcul de la trajectoire réelle à
chaque pas de la trajectoire discrete.

Soit l'exemple suivant de fichier de paramétrage du modèle
LotkaVolterra:

#+begin_src javascript
{
    "ALGORITHM_PARAMETERS": {
        "COMPUTE_MIN_TIME": 0,
        "COMPUTE_VIABLE_SET": false,
        "GRID_REFINMENTS_NUMBER": 0,
        "INITIAL_POINTS": [
            [1.5, 1]
        ],
        "INTERMEDIATE_SAVINGS": 0,
        "ITERATION_STOP_LEVEL": 0,
        "LEVEL": 1,
        "NUMBER_OF_TRAJECTORIES": 1,
        "PROJECTION_AXIS": [
            1,
            0
        ],
        "SAVE_BOUNDARY": 1,
        "SAVE_PROJECTION": 0,
        "SAVE_SLICE": 0,
        "SAVE_SLICE_BOUND": 0,
        "SAVE_SUBLEVEL": 0,
        "SAVE_VIABSET_LIGHT": 0,
        "SET_TYPE": 1,
        "TARGET_OR_DEPARTURE": 1,
        "TRAJECTORY_TYPE": "CAUTIOUS",
        "BUBBLE_RADIUS": 0.5,
        "REAL_TIME_STEPS_PER_DISCRETE_STEP": 1
    },
    "CONTROL_PARAMETERS": {
        "CONTROL_DIMENSION": 1,
        "CONTROL_GRID_POINTS": [
            11
        ],
        "CONTROL_MAX_VALUES": [
            1
        ],
        "CONTROL_MIN_VALUES": [
            0
        ]
    },
    "GRID_PARAMETERS": {
        "GRID_MAIN_DIR": 0,
        "GRID_METHOD": 1,
        "LOWER_LIMIT_IS_NOT_CONSTRAINT": [
            0,
            0
        ],
        "OUTPUT_FILE_PREFIX": "LotkaVolterra",
        "SLICE_DIRECTIONS": [
            0,
            0
        ],
        "SLICE_LEVELS": [
            1,
            1
        ],
        "SLICE_LEVELS_DISCRETE": [
            0,
            0
        ],
        "STATE_DIMENSION": 2,
        "STATE_GRID_POINTS": [
            501,
            501
        ],
        "STATE_MAX_VALUES": [
            4,
            4
        ],
        "STATE_MIN_VALUES": [
            0,
            0.1
        ],
        "STATE_PERIODIC": [
            0,
            0
        ],
        "UPPER_LIMIT_IS_NOT_CONSTRAINT": [
            0,
            0
        ]
    },
    "SYSTEM_PARAMETERS": {
        "DYNAMICS_TYPE": 1,
        "DYN_BOUND": 1,
        "DYN_BOUND_COMPUTE_METHOD": 1,
        "IS_TIMESTEP_GLOBAL": 0,
        "LIPSCHITZ_CONSTANT": 1,
        "LIPSCHITZ_CONSTANT_COMPUTE_METHOD": 1,
        "TIME_DISCRETIZATION_SCHEME": "EL",
        "TIME_HORIZON": 10
    }
}
#+end_src

Par exemple, pour une valeur de REAL_TIME_STEPS_PER_DISCRETE_STEP
valant 1, le début de la sortie dans le fichier
~LotkaVolterra-traj-1.dat~ devrait être la suivante:

#+begin_example
     1.50000000      1.00000000      0.00000000      0.00000000 
     1.50000000      1.02312486      0.04624973      0.00000000 
     1.49839572      1.04678449      0.09249946      0.00000000 
     1.49515354      1.07091357      0.13874919      0.00000000 
     1.49024983      1.09543826      0.18499892      0.00000000 
     1.48367188      1.12027614      0.23124865      0.00000000
#+end_example

La troisième colonne ici indique le temps. Si l'on met
REAL_TIME_STEPS_PER_DISCRETE_STEP à 10 (c'est-à-dire, qu'au lieu
d'avoir une seule itération de calcul de trajectoire réelle on en a
dix) on obtient le début de sortie suivant:

#+begin_example
     1.50000000      1.00000000      0.00000000      0.00000000 
     1.50000000      1.00231249      0.00462497      0.00000000 
     1.49998396      1.00463032      0.00924995      0.00000000 
     1.49995183      1.00695344      0.01387492      0.00000000 
     1.49990360      1.00928178      0.01849989      0.00000000 
     1.49983921      1.01161528      0.02312486      0.00000000 
     1.49975864      1.01395388      0.02774984      0.00000000 
     1.49966185      1.01629750      0.03237481      0.00000000 
     1.49954881      1.01864608      0.03699978      0.00000000 
     1.49941949      1.02099956      0.04162476      0.00000000 
     1.49927387      1.02335787      0.04624973      0.00000000   
#+end_example

Cet extrait présente 10 lignes. On peut voir que le temps indiqué pour
la dixième ligne est celui de la deuxième ligne de l'exemple pour
REAL_TIME_STEPS_PER_DISCRETE_STEP valant 1. Le paramètre sert à
indiquer le nombre de pas de temps de la trajectoire réelle entre
chaque pas de temps de la trajectoire discrète. Il permet donc de
"lisser" la trajectoire (et même plus, la trajectoire donnée sera plus
proche de la trajectoire réelle pour une méthode d'approximation
linéaire donné)

** Déplacement et modification de la logique de trajectoire dans des classes

*** Quoi

La logique de trajectoire a été déplacée et les fonctionnalités ont
été étendues. Il existe maintenant deux classes mère ~Trajectory~ et
~TrajectoryPoints~. Ces deux classes sont purement abstraites (des
interfaces).

Une classe dérivant de ~TrajectoryPoints~ est une classe
pouvant stocker des points de l'espace d'état et des marqueurs de
temps (timeStamps) et pouvant être interrogée avec des méthodes
~getLastPoint()~ ou ~getTimeStamps()~ par exemple. Toute trajectoire a
également une durée pouvant être demandée par ~getDuration()~. L'interface
pourra possiblement être étendue pour avoir des statistiques sur la
trajectoire elle-même.

*** Comment

Une classe dérivant de ~Trajectory~ est une classe stockant les mêmes
informations qu'une classe dérivant de ~TrajectoryPoints~ mais
possédant en plus un historique des indices de points de
contrôle. J'ai préféré stocker les indices plutôt que les points
eux-même parce que de nombreuses trajectoires ont besoin de contrôles
"proches" du contrôle enregistré, et que le stockage des indices
permet de ne pas perdre l'information du voisinage dans l'ensemble des
contrôles.

Ces deux classes sont déclinées sous trois forme : une classe
"Storage", une classe "Empty" et une classe "Simulation".

Les classes "Storage" sont celles stockant à proprement parler une
trajectoire et pouvant également écrire cette trajectoire dans un
fichier à l'aide d'une méthode ~writeToFile~. Leurs constructeurs
demandent toujours un point de départ, et les méthodes pour ajouter des
points demandent les points à ajouter avec un marqueur de temps (et un
indice de contrôle en plus pour ~TrajectoryStorage~, ainsi la
trajectoire aura toujours la forme cohérente s_0 u_1 s_1 u_2 s_2
\dots u_n s_n avec s_i un état et u_i un contrôle).

Les classes "Empty" possèdent la même interface mais renvoient une exception
si jamais elles sont interoggées. Les seules méthodes pouvant être
utilisées sans lancer d'exception sont celles ajoutant des points, qui
n'ont aucun effet.
x
Les classes "Simulation" peuvent être créées à partir des classes
"Storage" avec une méthode ~asSimulation()~. Il est important que lors
de la durée de vie de la trajectoire simulée, on ne modifie pas la
classe trajectoire initiale. En effet, les classes "Simulation" ne sont
pas des copies des trajectoires réelles, elles possèdent simplement
une référence sur la classe ayant appelé ~asSimulation()~ et
*modifient la classe Trajectoire l'ayant créée*. Elles sont
identiques en fonctionnement aux classes "Storage", la seule
différence est dans leur destructeur. En effet, une fois que la classe
"Simulation" est détruite, elle supprime de la classe "Storage"
l'ayant créée toutes les modifications qu'elle a apportée. Le bout de
code ci-dessous explique son utilisation attendue:

#+begin_src C++
  Trajectory traj(/* ... */);
  // Ajout de points...

  { // (1) Nouvel environnement local
      
      TrajectorySimulation simulation = traj.asSimulation();
      // Simulation...
      // On ajoute des points à la simulation      
      simulation.addPoint(/* ... */);

      //On peut interroger la simulation
      double time = simulation.getLastTimeStamp();

      // Il ne faut pas toucher à la classe traj initiale,
      // elle modifiée par la simulation

  } // TrajectorySimulation est détruite,
    // traj est dans le même état qu'à l'appel asSimulation(),
    // donc dans le même état qu'en début du bloc (1)

  // traj peut être modifiée librement
#+end_src

*** Pourquoi

Les buts de cette hierarchie de classes de trajectoire sont:
- S'assurer par l'interface de la classe que la trajectoire
  enregistrée a la bonne forme. 
- Permettre des fonctionnements différents de la trajectoire selon
  l'utilisation ("Empty" et "Simulation" sont pour des cas
  d'utilisations particuliers où l'on ne veut pas enregistrer la
  trajectoire dans les fichiers de sortie).
- Séparer la gestion du stockage de la trajectoire avec la recherche
  du contrôle viable.
- Permettre l'extension future de la fonctionnalité de la trajectoire.

Les classes "Storage" sont le cas d'utilisation par défaut où l'on
veut simplement stocker la trajectoire dans un fichier de sortie à la
fin du calcul de trajectoire.

Les classes "Empty" servent pour les trajectoires
~CAUTIOUS~. En effet, pour réaliser la simulation de bulle, on utilise
~computeViableTrajectoryIteration~. Cette dernière cherche à
enregistrer la progression de la trajectoire dans des classes
~Trajectory~ et ~TrajectoryPoints~. Le souci étant que l'on a pas
besoin d'enregistrer les points dans le cas d'une trajectoire simulée,
d'où l'existance des classes "Empty" servant juste à satisfaire
l'interface de ~computeViableTrajectoryIteration~.

Les classes "Simulation" servent pour les trajectoires par liste de
stratégies. En effet, dans le cas de trajectoires possédant une
stratégie ~BUBBLE~, les stratégies utilisée pour la simulation peuvent
avoir besoin, contrairement à ~CAUTIOUS~ où l'on connaît les besoins
de l'algorithme par défaut (c'est-à-dire, aucun besoin d'historique),
les stratégies ont potentiellement besoin de l'historique de la
simulation. On ne veut par contre pas que la trajectoire simulée soit
conservée à la fin de la prise de décision par la stratégie de
bulle. C'est pour cela que ces classes ont été pensée pour "ne laisser
aucune trace" de leur utilisation lors de leur destruction.

** Création et déplacement de la logique de bulle des trajectoires prudentes dans une classe Bulle
*** Quoi

Une classe ~Bubble~ a été créé pour ranger la logique de bulle
nécessaire au trajectoire prudentes. Celle-ci contient différents
algorithmes cherchant principalement à savoir si un point est dans la
bulle ou à trouver si la bulle touche un bord.

*** Comment

La bulle contient comme seule méthode la modifiant une méthode
permettant de déplacer son centre ~setCenter~. Toutes les autres
méthodes sont des méthodes de recherche de points validant certaines
conditions ou des prédicats cherchant à savoir si la bulle touche un
bord.

*** Pourquoi

Lors d'une trajectoire prudente, on a besoin de la logique d'une
"bulle" qui regarde s'il n'y a pas un bord autour de nous. Comme cette
logique commençait à être entremélée à cette de ~ViabiBitSet~. De
plus, elle était pas évidente à manipuler, menant à des erreurs
de code possibles et les méthodes prenaient en paramètre beaucoup
d'arguments car la bulle n'utilisait pas les attributs de
~ViabiBitSet~. J'ai donc préféré déplacer la logique dans une classe
~Bulle~ qui contient différents algorithmes de bulle, des méthodes
pour déplacer son centre et une initialisation qui permet d'éviter les
erreurs dans l'initialisation des paramètres.

** Optimisations
*** Optimisations de Grid::numToIntCoords et Grid::numToIntAndDoubleCoords

Les méthodes ~numToIntAndDoubleCoords~ et ~numToInCoords~ de
~Grid.cpp~ sont des méthodes pouvant cumuler à elle seules plus de la
moitié du temps d'exécution du programme. Il est important qu'elle
soient les plus efficaces possibles dans leur calcul.

Initialement, elle étaient implémentées ainsi (en enlevant les print):

#+begin_src C++
  void Grid::numToIntCoords(unsigned long long int num, unsigned long long int *res)
  {

      unsigned long long int temp = num;

      for (int d = dim - 1; d >= 0; d--)
      {
          res[d] = temp % nbPoints[d];
          temp = (temp - res[d]) / nbPoints[d];

      }
  }

  void Grid::numToIntAndDoubleCoords(unsigned long long int num, unsigned long long int *resI, double *resD)
  {
      unsigned long long int temp = num;
      for (int d = (int) dim - 1; d >= 0; d--)
      {
          resI[d] = temp % nbPoints[d];  // coordonn�es enti�res du point
          resD[d] = limInf[d] + step[d] * resI[d] + 0.5 * gridType * step[d];
          temp = (temp - resI[d]) / nbPoints[d];
      }
  }
#+end_src

À l'aide de [[https://ftp.gnu.org/old-gnu/Manuals/gprof-2.9.1/html_mono/gprof.html][Gprof]], le profileur de code GNU, on peut voir que le temps
d'exécution initial est le suivant:

#+begin_example
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 40.62      2.08     2.08 23199153     0.00     0.00  Grid::numToIntAndDoubleCoords(unsigned long long, unsigned long long*, double*)
 13.28      3.52     0.68  6494096     0.00     0.00  Grid::numToIntCoords(unsigned long long, unsigned long long*)
#+end_example

L'exemple utilisé ici est l'exemple de la trajectoire prudente donné
dans l'exemple au début de ce fichier. Les options de compilations
sont -O3 et -flto. On peut voir que *plus de 50% du temps
d'exécution est dû à ces méthodes*.

La première optimisation apportée est dûe au fait que les divisions
réalisée pour mettre à jour la valeur de temp sont des divisions
entières. Ceci implique donc que si ~resI[d] = temp % nbPoints[d]~,
alors ~(temp - resI[d]) / nbPoints[d]~ est équivalent à ~temp /
nbPoints[d]~. Le calcul de temp peut donc être simplifié:

#+begin_src C++
  void Grid::numToIntCoords(unsigned long long int num, unsigned long long int *res)
  {

      unsigned long long int temp = num;

      for (int d = dim - 1; d >= 0; d--)
      {
          res[d] = temp % nbPoints[d];
          temp /= nbPoints[d];

      }
  }

  void Grid::numToIntAndDoubleCoords(unsigned long long int num, unsigned long long int *resI, double *resD)
  {
      unsigned long long int temp = num;
      for (int d = (int) dim - 1; d >= 0; d--)
      {
          resI[d] = temp % nbPoints[d];  // coordonn�es enti�res du point
          temp /= nbPoints[d];
          resD[d] = limInf[d] + step[d] * resI[d] + 0.5 * gridType * step[d];
      }
  }

#+end_src

Ce code là possède également l'avantage d'indiquer clairement au
compilateur que l'on fait une division avec ~nbPoints[d]~ et un
modulo. Ceci est optimisable en [[http://www.c-jump.com/CIS77/MLabs/M11arithmetic/M11_0090_div_example.htm][une seule instruction sur certains
processeurs]]. Le temps d'exécution devient alors:

#+begin_example
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 39.55      1.74     1.74 23199153     0.00     0.00  Grid::numToIntAndDoubleCoords(unsigned long long, unsigned long long*, double*)
  7.05      3.28     0.31  6494096     0.00     0.00  Grid::numToIntCoords(unsigned long long, unsigned long long*)
#+end_example

Les pointeurs sur les tableaux pourraient en théorie être victimes
d'aliasing. Cela signifie que le compilateur ne peut pas affirmer que
les tableaux resI, resD, limInf...ect ne pointent pas sur les mêmes
zones mémoire. Pour permettra au compilateur de pouvoir affirmer cela
(et ainsi gagner en performance potentielle selon les options de
compilation en ne lisant qu'une seule fois les contenus des tableaux),
on introduit des variables intermédiaires:

#+begin_src C++
  void Grid::numToIntAndDoubleCoords(unsigned long long int num, unsigned long long int *resI, double *resD)
      {
      unsigned long long int temp = num;
      for (int d = dim - 1; d >= 0; d--)
      {
          const unsigned long long resId = temp % nbPoints[d];  // coordonn�es enti�res du point
          const double resDd = limInf[d] + step[d] * (resId + 0.5 * gridType);
          temp /= nbPoints[d];
          resI[d] = resId;
          resD[d] = resDd;
      }

      }
void Grid::numToIntCoords(unsigned long long int num, unsigned long long int *res)
    {

    unsigned long long int temp = num;

    for (int d = dim - 1; d >= 0; d--)
	{
        const unsigned long long resD = temp % nbPoints[d];
        temp /= nbPoints[d];
        res[d] = resD;
	}

    }
#+end_src

Voici les résultats finaux:

#+begin_example
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 25.23      1.67     0.83 23199153     0.00     0.00  Grid::numToIntAndDoubleCoords(unsigned long long, unsigned long long*, double*)
  5.17      2.60     0.17  6494096     0.00     0.00  Grid::numToIntCoords(unsigned long long, unsigned long long*)#+end_example
#+end_example
  
*** Optimisation de Grid::localizePoint

Après les optimisations de la section précédente, sur l'exemple donné,
le début du profil de code donne:

#+begin_example
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 25.53      0.84     0.84  5865651     0.00     0.00  SysDyn::FDiscretRK4(double*, double*, double*, double)
 25.23      1.67     0.83 23199153     0.00     0.00  Grid::numToIntAndDoubleCoords(unsigned long long, unsigned long long*, double*)
 14.89      2.16     0.49 11659675     0.00     0.00  Grid::localizePoint(double*)
  8.21      2.43     0.27 30412241     0.00     0.00  Grid_BitSet::isInSet(unsigned long long*)
  5.17      2.60     0.17  6494096     0.00     0.00  Grid::numToIntCoords(unsigned long long, unsigned long long*)
  4.26      2.74     0.14     2787     0.00     0.00  ViabiBitSet::CaptureBasin()
  3.65      2.86     0.12  5862727     0.00     0.00  SysDyn::checkKernelRelation(double*)
  3.34      2.97     0.11                             _init

...inférieur à 0.1 seconde, moins de 3% du temps d'exécution...
#+end_example

Un point d'optimisation simple est ~Grid::localizePoint~. Celui-ci
était implémenté ainsi initialement:

#+begin_src C++
unsigned long long int Grid::localizePoint(double *coords)
    {
    unsigned long long int *indiceCell = new unsigned long long int[dim];
    for (int k = 0; k < dim; k++)
	{
        indiceCell[k] = (unsigned long long int) floor((((coords)[k] - limInf[k]) / step[k]));

	if (indiceCell[k] == (nbPoints[k] - 1))
    {
	    indiceCell[k]--;
    }
	}
    unsigned long long int numCell = indiceCell[0];

    for (int i = 0; i < dim - 1; i++)
	{
	numCell = numCell * (nbPoints[i + 1]) + indiceCell[i + 1];

	}
    delete[] indiceCell;
    return numCell;
    }
#+end_src

Les allocations mémoire sont des opérations chères, et ici il est
facile de l'éviter. On peut en plus faire un décalage des indices
dans les boucles for pour éviter les ~i+1~:

#+begin_src C++
  unsigned long long int Grid::localizePoint(double *coords)
  {
      unsigned long long int numCell = (unsigned long long int) floor((((coords)[0] - limInf[0]) / step[0]));
      if (numCell == (nbPoints[0] - 1)) numCell--;

      for (int i = 1; i < dim; i++)
      {
          unsigned long long int indiceCell = (unsigned long long int) floor((((coords)[i] - limInf[i]) / step[i]));
          if (indiceCell == (nbPoints[i] - 1)) indiceCell--;
          numCell = numCell * (nbPoints[i]) + indiceCell;

      }
      return numCell;
  }
#+end_src

Le résultat au profileur est alors le suivant:
#+begin_example
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
  8.70      2.16     0.32 11659675     0.00     0.00  Grid::localizePoint(double*)
#+end_example

Une autre amélioration simple est de juste enlever la fonction
~floor~. Puisqu'on travaille avec des nombres positifs, faire une
simple cast sera plus efficace et clair pour le compilateur:

#+begin_src C++
  unsigned long long int Grid::localizePoint(double *coords)
  {
      unsigned long long int numCell = (unsigned long long int) (((coords)[0] - limInf[0]) / step[0]);
      if (numCell == (nbPoints[0] - 1)) numCell--;

      for (int i = 1; i < dim; i++)
      {
          unsigned long long int indiceCell = (unsigned long long int) (((coords)[i] - limInf[i]) / step[i]);
          if (indiceCell == (nbPoints[i] - 1)) indiceCell--;
          numCell = numCell * (nbPoints[i]) + indiceCell;

      }
      return numCell;
  }
#+end_src

Le résultat devient alors:

#+begin_example
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name   
  4.61      2.22     0.13 11659675     0.00     0.00  Grid::localizePoint(double*)
#+end_example

** Utilisation de const
*** Quoi

Les fonctions utilisateur ont maintenant des paramètres d'entrée
~const~ (quand cela a du sens). Les méthodes des objets se servant de
ces méthodes utilisateurs ont été mises à jour en conséquence.

Les méthodes de grille aussi ont été modifiée pour être avoir le
modificateur ~const~ lorsque cela est pertinent.

*** Pourquoi

L'intérêt principal est pour le programmeur d'indiquer que
l'utilisateur ou le programmeur lui-même ne doit pas modifier les
paramètres d'entrée des fonctions/méthodes ~const~, et cela documente
mieux les fonctions et méthodes annotées. Ceci était censé
permettre au compilateur d'accélerer les fonctions et méthodes
utilisant ~const~, mais les vitesses d'exécutions sont équivalentes.

** Modification de tableaux d'entiers contenant des valeurs booléenne en tableaux de booléen

Ceci indique plus clairement ce que veulent dire les tableaux
~periodic~ et la variable ~gridType~ (cette dernière a été renommée en
~arePointsGridCenters~).

** Fonctionnalité de trajectoires prudentes lourdes

*** Pourquoi

La trajectoire que j'ai appelé prudente possède un problème majeur
lorsqu'elle est couplée à une préférence utilisateur : si la
préférence utilisateur sur le contrôle est contradictoire avec le
contrôle choisi par la bulle, on se retrouve souvent avec un phénomène
de "tremblottements" de la trajectoire.

Ces "tremblottements" proviennent du fait que la bulle ne
soit pas de taille infinie, et donc qu'il existe un moment à partir
duquel réaliser le contrôle du bord nous amène à avoir une bulle ne
touchant plus de bord. À ce moment là, l'algorithme prudent choisit de
faire une itération de l'algorithme "par défaut" qui, s'il est opposé
à la préférence de la bulle, peut ramener à bulle à détecter un
bord. En détectant à nouveau un bord, il est probable que la
trajectoire simulée retouche un bord, que la trajectoire voulue par la
consiste à prendre le contrôle de bord et ainsi de suite.

*** Quoi

Pour éviter les tremblottements, l'idée était d'utiliser un contrôle viable dit
"lourd" évitant ces tremblottements. Lorsque la bulle touche un bord
avec sa simulation, l'algorithme est identique à l'algorithme de
trajectoire prudente. Le cas où l'algorithme est différent est lorsque
la bulle ne touche pas de bord (lors de la simulation ou qu'aucun
point de la bulle n'est un bord). Si aucun bord n'est touché lors de
la simulation, on
réutilise le même contrôle que l'itération précédente si c'est
possible (ce qui devrait être le cas, sinon cela signifie que la bulle
est trop petite). La simulation doit prendre en compte la trajectoire
qui serait empruntée sans la bulle, celle-ci utilise donc également un
contrôle lourd pour déterminer le bord.

L'algorithme schématique est le suivant:

#+begin_example
Paramètres: position initiale,
            durée de la trajectoire,
            tableau indicé des controles possibles,
            bulle d'un rayon et de forme donné par l'utilisateur,
            contrôle initial u

Tant qu'il nous reste du temps:
    S'il y a un bord touchant la bulle:
        T <- (1b) Trajectoire simulée jusqu'à être arrivé à un bord
                 ou être sorti de la bulle utilisant le contrôle u
        Si T ne se termine pas sur le bord
            Appliquer le contrôle u à la position courante
        Sinon:
            ub <- Indice du contrôle viable appliqué au bord s'il existe,
                  sinon celui appliqué l'itération précédente
            u  <- (2) Premier indice de contrôle viable au point courant
                      en partant de ub et en parcourant de manière croissante
                      les préférences utilisateurs, puis de manière
                      décroissante depuis ub si toujours aucun n'a été trouvé
            Appliquer le controle d'indice u au point courrant
        Fin Si
    Sinon:
        Appliquer le contrôle u à la position courante
    Fin Si
Fin Tant Que
#+end_example

Comme on peut voir, la seule différence par rapport à l'algorithme
prudent simple est la simulation en (1b) qui n'utilise pas l'algorithme
par défaut comme le (1) de l'algorithme prudent et l'application du
même contrôle dans les cas où avant était utilisé l'algorithme par
défaut.

L'algorithme (1b) est le suivant:

#+begin_example
Paramètres: position courante, contrôle utilisé u

Copier les informations de la position courante dans une copie Cp

Tant que l'on est dans la bulle
      et que l'on est pas sur un bord
      et que l'on a pas dépassé un nombre maximal d'itérations:

      dt <- pas de temps choisi en position courante

      Ccp <- copie de Cp
      Faire
          Ccp <- Appliquer u en la position courante avec le pas de temps dt
          dt <- dt / 2
      Jusqu'à ce que Ccp soit valide ou que Cp = Ccp
      Cp <- Ccp      
Fin Tant Que

Retourner Cp et un booléen indiquant si on est sur le bord
#+end_example

Il est possible que pour un pas de temps trop grand, bien
qu'on ne soit pas au bord que le contrôle ne soit pas viable. Dans le
cas de l'algorithme (1), on ne faisait que planter si
l'itération par défaut échoue parce que l'itération par défaut cherche
pour tous les contrôles et plusieurs pas de temps, ce qui n'est pas le
cas de la règle simple "appliquer le même contrôle tant que c'est
possible". C'est pour ça que l'algorithme (1b) peut chercher
à diminuer le pas de temps si le contrôle n'est pas viable pour un pas
de temps donné mais pour une position pas au bord.

*** Comment

Bien que les deux algorithmes soient extremement proches l'un de
l'autre, j'ai préféré les séparer en deux méthodes distinctes :
~computeViableTrajectory~ et ~computeViableTrajectoryHeavy~. La
simulation de l'algorithme (1b) est elle réalisée par
~findPositionAtBorderHeavy~ qui applique un contrôle donné jusqu'à ce
que l'on sorte de la bulle, que l'on touche un bord ou que l'on
dépasse un nombre maximal d'itération.

Il s'utilise de la même façon que la trajectoire prudente. La seule
différence est qu'il faut donner à ~TRAJECTORY_TYPE~ dans le JSON la valeur
~CAUTIOUS_HEAVY~ ou ~WEIGHTED_CONTROLS_CAUTIOUS_HEAVY~.

** Limitation sur le contrôle initial

Le contrôle initial (INITIAL_CONTROL) du JSON n'était pas
nécessairement dans l'espace des contrôles de l'utilisateur. Ceci
n'était pas un problème avec l'architecture du code initiale, mais
cela va poser souci avec les changements futurs. J'ai donc restreint
le contrôle initial à l'ensemble des contrôles et ajouté un warning
dans ~ParametersManager.cpp~ quand le contrôle initial est modifié
pour être restreint dans les bornes.

** Ajout de getGrid dans SysDyn

Ceci est utile pour simplifier les méthodes des ~ControlPickStrategies~.

** Recalage du point de grille sur le point réel dans la trajectoire VD de ViabiBitSet

Le programme utilisait à chaque étape le successeur renvoyé par
~findViableDiscreteSuccessor~ de l'étape précédente et cherchait à
rapprocher le plus possible la trajectoire réelle de ce point
discret. Le souci avec cet algorithme est que la trajectoire réelle
peut finir plus proche d'un autre point de grille que le successeur
renvoyé. J'ai donc décidé de modifier l'algorithme en remplaçant la
ligne affectant au point suivant le résultat de
~findViableDiscreteSuccessor~ par une affectation du point le plus
proche de grille à la trajectoire réelle selon
~GridBitSet::getNearestPointInSet~. Ainsi, on évite de possibles
désynchronisations entre la trajectoire réelle et discrète.

** Modification de la lecture de fichier JSON dans ParametersManager

La lecture de tableau qui était réalisé par plusieurs méthodes nommées
~readTabData~ et ~readDoubleTabData~ ont été remplacée par un seul
template de méthode de même nom. De plus, il fallait toujours vérifier
que le tableau existe, puis initialiser le tableau avec des valeurs
par défaut, puis appeler la méthode de lecture (qui pouvait planter si
le tableau JSON lu contenait une valeur que l'arbre ne sait pas lire).

Les méthodes templates réalisent maintenant le travail suivant:
1. Vérifier si le tableau JSON existe
2. S'il n'existe pas, remplir le tableau du code avec la valeur par
   défaut (nouveau paramètre de ces méthodes)
3. S'il existe, remplir le tableau du code avec la valeur utilisateur,
   ou la valeur par défaut dans une case donnée si le JSON est invaide
   pour cette case

Une autre méthode a été ajouté si une valeur non valide dans le
tableau JSON doit plutôt être ignorée que mise à une valeur par
défaut. Par exemple, si on attend du JSON un tableau d'entier et que celui-ci
contient ~[1, 2, "CHAT", 4]~, la méthode ~readTabDataSkipInvalid~
initialisera le tableau (et modifiera son paramètre de taille) pour
que le tableau vale ~[1, 2, 4]~. Ceci est utile pour les trajectoires
de type "liste de foncteur" expliqué ci-après.

** Trajectoire par stratégies
*** Quoi

Il est possible de préciser un tableau que de que l'on va nommer des
"stratégies" comme TRAJECTORY_TYPE.

Une stratégie est un algortihme qui a comme objectif de soit choisir
un contrôle, soit laisser le contrôle suivant choisir à sa place en ne
renvoyant aucun contrôle. Ces stratégies se succèdent l'un après
l'autre en se passant le contrôle choisi (ou non) pour décider du
contrôle choisi. Ce choix est fait pour chaque pas de temps de
l'algorithme de calcul de trajectoire.

Le "contrôle choisi ou non" est en pratique un objet pouvant avoir
deux "types" de valeurs: soit une paire ~(contrôle, pas de temps)~
indiquant qu'un contrôle a été décidé avec le pas de temps donné, soit
une valeur donnant la raison pour laquelle un contrôle n'a pas été
trouvée. Il est
possible que je nomme simplement "contrôle" cette paire dans les
explications des stratégies, bien que ce ne soit pas nécessairement
correct, par souci de brieveté.

Le tuple ~(contrôle, pas de temps)~ n'est pas nécessairement
viable, c'est à la responsabilité de la personne ayant écrit la
liste de stratégies de s'assurer qu'en sortie de liste le contrôle
avec le pas de temps donné soit viable en la position courante. Ceci
permet d'écrire des stratégies renvoyant des contrôles utiles à la
stratégie suivante de la liste. En effet, on peut imaginer que le
contrôle invalide puisse être un contrôle de grille impossible à
réaliser avec la trajectoire réel. Ce contrôle de grille pourrait
alors être rectifié par un contrôle proche viable par une autre
stratégie.

Un exemple de stratégie, et la stratégie la plus simple, est la
stratégie first, qui suit l'algorithme suivant:

#+begin_example
Paramètres: indice de contrôle éventuel choisi par la stratégie précédente (opt)
            position courante (pos)
            Pas de temps choisi pour la grille en position courante (rho)

Si opt est une paire (contrôle, pas de temps):
    Renvoyer opt
Sinon:
    cu <- Premier contrôle viable de grille
          (selon l'ordre imposé par preferedControlIndexes)
    gridSucc <- Successeur de grille obtenu en utilisant cu
    (cuReel, rhoReel) <- Contrôle viable réel qui permet de se rapprocher
                         le plus possible de gridSucc,
                         avec rhoReel le pas de temps choisi pour se rapprocher
                         
    Si cu n'existe pas:
        Renvoyer que la stratégie est insatisfaite
    Sinon Si cuReel n'existe pas:
        Renvoyer (cu, rho)
    Sinon:
        Renvoyer (cuReel, rhoReel)
    FinSi
FinSi            
#+end_example

Cet algorithme est la version sous forme de stratégie de l'algorithme
"viable par défaut" (représenté par "TRAJECTORY_TYPE": "VD"). Il est
donc équivalent d'écrire:

#+begin_src javascript
  {
    "TRAJECTORY_TYPE": "VD",
    // ou 
    "TRAJECTORY_TYPE": ["FIRST"],
  }
#+end_src

(à ceci près que l'algorithme viable par défaut cherchera à recaler la
trajectoire réelle sur la trajectoire de grille quand il ne trouve pas
de solution, alors que l'algorithme par liste de stratégie ["FIRST"]
plantera si aucun contrôle réel n'est trouvé.)

L'avantage de la modélisation sous forme de stratégie est que
l'on peut composer les stratégies pour créer un nouvel algorithme. Par
exemple, imaginons que l'on veuille l'algorithme suivant:

1. Si c'est possible, choisir le même contrôle que le contrôle
   précédent (contrôle lourd)
2. Sinon, choisir le premier viable

Une stratégie "HEAVY" existe, représentant le choix 1. La
stratégie représentant le choix 2. est "FIRST". Donc, l'algorithme
ci-dessus se représente sous la forme ["HEAVY", "FIRST"].

*** Comment

La représentation dans le code de cette logique se fait à l'aide de
deux interfaces : ~ControlPicker~ et ~ControlPickStrategy~.

~ControlPicker~ est une interface ayant une seule méthode:
~pickControl~. La méthode ~pickControl~ d'un ~ControlPicker~ cherchera
simplement à parcourir la liste
des stratégies et effectuer le travail de transmission des sorties de
l'un au entrées de l'autre. Il se décline en une seule classe fille :
~ControlPickerBitSet~ (une classe ~ControlPickerMicroMacro~ sera très
certainement implémentée prochainenemt). Il est possible d'effectuer
uniquement un sous-ensemble des stratégies avec la méthode
~pickControlFromSubPickerList~, la première méthode appelant seulement
la seconde avec un début de sous-liste à 0.

~ControlPickStrategy~ est une interface ayant une seule méthode:
~pickControl~. La méthode ~pickControl~ d'une ~ControlPickStrategy~ a
pour objectif de choisir un contrôle ou de déléguer cette tâche à la
stratégie suivante.

La seule obligation que possède une liste de stratégies est de
renvoyer après questionnement de toutes les stratégies une paire
(contrôle, pas de temps) valide.

Il n'est pas à la charge d'une classe ~ControlPickStrategy~ de

- Renvoyer une paire viable (la paire contrôle + pas de temps peut
  être invalide, mais si la paire renvoyée de la dernière stratégie
  est invalide, le programme peut s'arrêter).
- Modifier les trajectoires passées en argument pour la consultation
  (à moins de savoir ce que l'on fait, c'est même interdit). Les
  trajectoires passées sont des ~TrajectorySimulation~, donc les
  modifications seront supprimées une fois que toutes les stratégies
  ont été questionnées.
- Modifier le système dynamique passé en argument pour la consultation
  (sauf éventuellemnt pour une fonction de tri des indices
  personnalisée, comme pour "ORDER" par exemple, dans quel cas faire
  de la modification de la fonction ~sortIndexes~ la seule action
  réalisée par la stratégie est une bonne pratique).  
- Plus généralement, une méthode ~pickControl~ d'une
  ~ControlPickStrategy~ n'a pas à toucher à ses paramètres d'entrée.

Il est préférable pour l'écriture de stratégies futures de suivre ces
lignes directrices suivie pour les stratégies existantes (pas
obligatoires, mais permettant une meilleure composition avec les
stratégies existantes):

- Afficher un message indiquant comment s'est déroulé le choix du
  contrôle (warn si échec, info si réussite)
- Vérifier si la stratégie précédente a choisi un contrôle ou non
- Renvoyer la paire de la stratégie précédente si elle existe si on ne
  prend pas en compte celle-ci dans notre décision
- Si la condition voulue par la stratégie ne peut pas être respectée,
  demander à la stratégie suivante de choisir

*** Pourquoi

La liste de stratégies permet une plus grande personnalisation de
l'algorithme de calcul de trajectoire. Il permettra même pour
l'utilisateur de créer sa propre classe ~ControlPickStrategy~ s'il a
une envie particulière qu'il pourra en plus composer avec des
stratégies déjà présentes.

Le fait que les stratégies sont toutes questionnées même si l'une
d'entre elle a renvoyé une solution viable est un choix qui a été fait
pour pouvoir avoir prochainement une stratégie se nommant "SMOOTH" qui
pourra écraser la solution donnée par la stratégie précédente pour un
contrôle permettant une trajectoire plus lisse.

Le fait qu'un stratégie n'ait jamais besoin de renvoyer un contrôle
viable et que cette vérification ne soit faite qu'à la fin permet à
notament à "FIRST" de tout de même renvoyer le contrôle de grille
viable, information pouvant être partagée ainsi à "BUBBLE".

La non-modification des paramètres d'entrée (ou en tout cas, leur
modification non-conseillée) est pour permettre le plus d'indépendance
possible entre les différents ~ControlPickStrategy~, la seule
information pouvant être modifiée au milieu du parcours des stratégies
étant le contrôle de la stratégie précédente est possiblement la
fonction de tri des indices de contrôles.

** Possibilité de donner un JSON en paramètre du programme

Le programme est normalement appelé avec le nom du modèle en
paramètre. Il est maintenant possible (optionnellement) d'ajouter
comme paramètre le nom du JSON (ou son emplacement relatif dans le
système de fichier, c'est-à-dire "../INPUT/nom_du_json").

La nouvelle signature de l'exécutable est donc
~./viabLabExe nom_du_modele [nom_du_json] [-t nombre_de_threads_OMP]~
(une valeur entre [] est une valeur optionnelle).

Une conséquence de cette modification est qu'un modèle n'a plus besoin
d'avoir une variable ~paramsFile~ tant qu'un nom de JSON est passé en
paramètre à l'exécutable.

** Possibilité d'ajouter des paramètres au modèles
*** Quoi

Les fichiers JSON peuvent maintenant avoir une section optionnelle
"MODEL_PARAMETERS" permettant de lister des constantes de modèle
pouvant être accedée par les modèles (fichiers .cpp dans source/data)
au travers du ~unordered_map<string, string>~ contenant les clés
valeurs passées dans le JSON.

Imaginons qu'un utilisateur souhaite charger une valeur
"CONSTANTE_MAGIQUE" dans son modèle. Pour cela, il lui suffit
d'ajouter dans le JSON une section "MODEL_PARAMETERS" comme suit:

#+begin_src javascript
  {
    "GRID_PARAMETERS": {/* à compléter */},
    "CONTROL_PARAMETERS": {/* à compléter */},
    "SYSTEM_PARAMETERS": {/* à compléter */},
    "ALGORITHM_PARAMETERS": {/* à compléter */},
    
    "MODEL_PARAMETERS": {
        "CONSTANTE_MAGIQUE": 42
    }    
}
#+end_src

Il peut alors récupérer la valeur dans son modèle en écrivant une
fonction ~loadModelData~ comme suit:

#+begin_src C++
  #include "../include/utilities.h"
  #include "../include/ParametersManager.h"

  // Pour la conversion de string à double, on a besoin de atof
  #include <cstdlib>

  extern "C" {

      double constanteMagique;

      void loadModelData(const ParametersManager *PM)
      {        
          const std::unordered_map<string, string> modelParams = PM->getModelParameters();
          // Conversion de string à double nécessaire
          constanteMagique = atof(modelParams.at("CONSTANTE_MAGIQUE").c_str());        
      }
      /* Il faut ajouter une fonction dynamics, jacobian...ect. */
   }
#+end_src

Le ~unordered_map~ ne contient que des valeurs sous forme de string,
il faut donc les convertir vers le type souhaité.

Il n'est pas possible de donner dans ce JSON de valeur "composite"
(array ou object).

*** Comment

~ParametersManager~ possède maintenant un attribut ~modelParameters~
qui est un ~unordered_map<string, string>~. Cet ensemble clé-valeurs
est rempli par les paires clé-valeur contenues dans le JSON dans la
section ~"MODEL_PARAMETERS"~. Il est possible de récupérer ces
paramètres au travers de la méthode ~getModelParameters~ de
~ParametersManager~.

*** Pourquoi

L'idée était de pouvoir lancer un modèle avec des paramètres constant
potentiellement différents à chaque exécution. Avant cette
modification, et l'ajout de la fonctionnalité
[[Possibilité de donner un JSON en paramètre du programme][d'ajouter un JSON en paramètre du programme]], il n'était pas possible
de faire ceci sans changer les constantes écrites "en dur" dans le
modèle et de recompiler le modèle.

De plus, puisqu'on peut donner le nom du modèle en entrée du
programme, il paraît assez naturel de pouvoir préciser les paramètres
de ce modèle de la même façon.

** Modification des conditions d'arrêt sur le nombre maximal d'itérations

Les conditions d'arrêt sur le nombre maximal d'itérations étaient
toujours de la forme suivante:

#+begin_src C++
  int nbIter = 0;
  while (nbIter <= NB_MAX_TRAJ_ITER) {
      /* ... */
      nbIter++;
  }
#+end_src

J'ai changé le inférieur ou égal en un simple inférieur pour que le
nombre d'itérations "NB_MAX_TRAJ_ITER" corresponde effectivement au
nombre d'itérations effectuées. Ceci était apparent dans les
trajectoires de bulles qui au travers de leur log, si
"NB_MAX_TRAJ_SIMULATIONS" était dépassé, affichaient qu'elle avaient
réalisé NB_MAX_TRAJ_SIMULATIONS+1.

** Stratégie de lissage

*** Quoi

Une stratégie permettant de créer des trajectoires lisses a été
ajoutée. Celle-ci s'appelle en donnant le nom de stratégie "SMOOTH"
dans le JSON.

Cette stratégie possède comme paramètre un angle maximal donné par le
paramètre JSON "MAX_ANGLE_RADIANS" ou "MAX_ANGLE_DEGREES". Cet angle
maximal correspond à l'angle maximal autorisé entre deux points de la
trajectoire réelle.

Sur le schéma ci-dessous, en notant A, B et C
trois points consécutifs de la trajectoire réelle, la stratégie SMOOTH
cherche à construire une trajectoire réelle telle que pour tous les
points A, B et C, l'angle \alpha formé par les vecteurs \vec{AB} et
\vec{BC} ne doit jamais dépasser la valeur du paramètre JSON
"MAX_ANGLE_[...]"

[[./img/smooth_trajectory_objective.png][Représentation de l'objectif de la trajectoire lisse]]

Il se peut que, pour un angle trop restreint, certaines propriétés
voulues par les stratégies précédentes ne puissent plus être garanties
(par exemple, une stratégie de bulle qui aurait un contrôle lissé
n'aura pas nécessairement en sortie le contrôle au bord, et donc
l'aspect de prévision de l'action prise au bord peut être en
partie perdue). Il ne faut donc pas donner un angle trop petit si l'on
veut que les autres stratégies aient une influence dans la decision.

*** Comment

La stratégie "SMOOTH" cherche à évaluer si le contrôle choisi par la
stratégie le précédant respecte la contrainte de l'angle. Si c'est le
cas, il le renvoie tel quel, sinon il cherche le contrôle l'amenant au
plus proche du point d'arrivée du contrôle choisi par la stratégie
précédente. "SMOOTH" peut donc être vu comme un "adoucisseur" local de
la pente de la trajectoire.

Si le contrôle produit déjà une trajectoire respectant l'angle, il est
renvoyé tel quel, sinon, un contrôle adouci est calculé. Le contrôle
adouci est calculé de la manière suivante par la méthode
~smoothControlClosestTo~:

#+begin_example
Paramètres: - paire (contrôle choisi par la stratégie précédente
                     pas assez lisse cuChoisi, pas de temps rho)
            - positions x_{t-1}, x_{t} des deux points précédents de la trajectoire
            - position x_{t+1} obtenue par application du schéma numérique
              en x_{t} avec le control cuChoisi
            - angle maximal autorisé alpha

cuMin <- cuChoisi
d <- +infini
              
Pour chaque cu parmi la liste des contrôles possible sauf cuChoisi:
   S'il est viable en x_{t}:
      y_{t+1} <- Application du schéma numérique en x_{t} avec cuChoisi

      AB <- \vec{x_{t-1} x_{t}}
      BC <- \vec{x_{t} y_{t+1}}
      
      Si distance(x_{t+1}, y_{t+1}) < d et angle(AB, BC) < alpha:

          cuMin <- cu
          d <- distance(x_{t+1}, y_{t+1})

      Fin Si
   Fin Si
Fin Pour

Renvoyer (cuMin, rho) si cuMin est différent de cuChoisi
#+end_example

En pratique, il peut arriver qu'aucun contrôle ne permette de
trajectoire assez lisse pour satisfaire la contrainte de
l'angle. C'est le seul cas d'erreur de "SMOOTH". Dans quel cas, on
aurait deux possibilités de résolution de l'erreur:

- On renvoie le contrôle de la stratégie précédente, en se disant que
  son contrôle était également le souhait de l'utilisateur
- On renvoie que la stratégie est insatisfaite, et c'est à la
  stratégie suivante de décider

J'ai finalement opté pour la deuxième solution, après avoir opté pour
la première au départ.

La première avait comme avantage de ne pas
avoir à gérer comme une erreur une trajectoire "pas assez lisse". Si
la trajectoire ne pouvait pas être lissée, elle effectuait alors une
itération comme si la stratégie SMOOTH n'était pas précisée.

Mais j'ai finalement choisi la seconde option pour deux raisons:
- Ceci était plus cohérent avec les autres stratégies, qui, si elle ne
  peuvent pas satisfaire leur critère, délèguent le choix à la
  stratégie suivante.
- Ceci permet une gestion de l'erreur personnalisée par la stratégie
  suivant la stratégie lisse
- On peut aussi vouloir arrêter le programme si une trajectoire lisse
  ne peut pas être trouvée, ce qui est possible en mettant "SMOOTH" en
  fin de liste de stratégies.

Le seul inconvénient est que la liste de stratégie devient plus longue
à écrire si la gestion d'erreur était simplement la même que la
stratégie devant être lissée. Au lieu de donner comme paramètre
~["FIRST", "SMOOTH"]~ comme on pouvait le faire avant, il faut
maintenant préciser le cas d'erreur ~["FIRST", "SMOOTH", "FIRST"]~.

*** Pourquoi

La stratégie
de lissage est pensée pour être associé à la stratégie de bulle. Son
objectif est d'avoir les avantages des trajectoires prudentes et des
trajectoires prudente lourdes.

La trajectoire prudente a comme avantage majeur par rapport à la
trajectoire prudente lourde de prendre en compte la préférence
utilisateur. Ceci avait comme défaut majeur un phénomène de changement
brutal de contrôle à chaque pas de temps, qui n'était pas
nécessairement réalisable. La trajectoire prudente lourde corrige cela
en prenant toujours le même contrôle tant que la simulation de bulle
ne touche pas de bord. Ainsi, on évite le problème du changement
brutal de contrôle à chaque pas de temps, mais on ne prend (quasiment)
pas en compte la préférence de l'utilisateur.

La stratégie de lissage ou "~SMOOTH~" cherche justement à avoir les
avantages de ces deux stratégies. L'idée est qu'au lieu de toujours
prendre le même contrôle, on choisit un contrôle parmi un
sous-ensemble de contrôles formant une trajectoire considérée "assez
lisse". On diminue ainsi la vitesse de variation du contrôle tout en
autorisant assez de variation localement pour permettre à la
préférence de l'utilisateur d'entrer en compte.

La spécification de la lisseur de la trajectoire comme un angle a
plusieurs avantage:

- Il est assez intuitif de comprendre l'effet de la valeur sur la
  trajectoire
- Elle se généralise à un nombre quelconque de dimension
- L'angle entre deux vecteurs est assez simple et rapide à calculer (1
  produit scalaire, 2 normes de vecteurs et un calcul d'arc cosinus)

L'angle peut être spécifié en radians ou en degré, en fonction de la
préférence de l'utilisateur, pour permettre à celui-ci de choisir la
représentation qui lui convient le mieux à lui ou son problème.

** Création de utilities.h

L'en-tête ~utilities.h~ a été créé pour regrouper toutes les fonctions
et constantes dont un utilisateur pourrait avoir besoin. Ce fichier
permet d'éviter l'import de ~defs.h~ contenant bien plus
d'informations que ce sont a besoin l'utilisateur.

Les constantes qui dans ~defs.h~ étaient définies à l'aide de
~#define~ sont maintenant définies à l'aide du mot clé ~const~. La
raison principale est qu'un nom de variable nommée ~pi~ était
également utilisée dans la librairie boost. Écrire ~#define pi ...~
n'était donc plus possible.

** Possibilité pour l'utilisateur de définir une classe de stratégie personnalisée
*** Quoi

L'utilisateur peut spécifier sa propre stratégie en définissant une
classe héritant de l'interface ~UserPickStrategy~. Cette classe
pourra être composée avec les autres stratégies pour permettre à
l'utilisateur de définir son propre algorithme de calcul de
trajectoire.

Pour l'utilisateur, cela se traduit par la création d'une classe dans
le modèle qui hérite de ~UserPickStrategy~. Pour que cette classe
puisse être instanciée par le programme, il est demandé à
l'utilisateur de définir une fonction qui instanciera sa classe
nouvellement crée à l'aide d'une allocation mémoire. Le nom de cette
fonction dépend du nom donné dans le JSON.

Par exemple, supposons que l'utilisateur ait écrit dans le fichier
JSON "~TRAJECTORY_TYPE~": ["~Intergalactique~", "~FIRST~"]. Il sera alors
supposé que la stratégie de l'utilisateur est accessible via une
fonction dont la signature est ~ControlPickStategy
*newIntergalactique(const TrajectoryParametersManager *)~. Le code de cette fonction
doit renvoyer une instance d'une classe héritant de
~ControlPickStrategy~ créé sur le tas (avec ~new~). Le nom de la
classe n'importe peu, elle n'est pas directement chargée par le
programme principal, mais dans cet exemple, une bonne idée serait de
l'appeler ~Intergalactique~. Pour donner un exemple complet, voici un
extrait d'un hypothétique fichier de modèle permettant d'instancier et
de charger une classe ~Intergalactique~:

#+begin_src C++
  #include "../include/ParametersManager.h"
  // Pour hériter de la classe UserPickStrategy, il faut sa déclaration
  #include "../include/ControlPickStrategy.h"

  extern "C" {
      // Nom de la classe quelconque
      // Il faut juste que la classe hérite publiquement de UserPickStrategy
      class Intergalactique final : public UserPickStrategy {

          // L'interface UserPickStrategy possède une seule méthode : pickControl
          OptionalCu pickControl(const OptionalCu &, ControlPickCriteria &criteria) override {
              // Pas de temps en position courante
              double rho = criteria.getTimeStep();
              // Renvoie toujours l'indice de contrôle 42 avec le pas de temps rho
              pickedControl p {rho, 42};
              return OptionalCu(p);
          }        
      };

      // Cette fonction est celle qui sera appelée par Viablab pour instancier la classe
      // Ce nom de fonction suppose qu'une stratégie "Intergalactique" est demandée dans le JSON
      UserPickStrategy *newIntergalactique(const TrajectoryParametersManager *) {
          return new Intergalactique();
      }
  }
#+end_src

*** Comment

Le fichier JSON est lu dans ~ParametersManager~. Pour déterminer la
liste des stratégies, ~ParametersManager~ cherche à lire une liste de
~ControlPickStrategyName~.

La classe ~ControlPickStrategyName~ correspond à une valeur représentant:
- soit une valeur de l'énumération ~PredefinedStrategyName~, contenant une valeur
pour chaque stratégie pré-définie.
- soit une chaîne de caractère, le champ correspondant à une valeur de
  type ~PredefinedStrategyName~ dans la classe vaut alors ~USER_STRATEGY~.

Dans le premier cas, le champ représentant le nom utilisateur sera une
chaîne de caractère vide.

À cette classe est associé un traducteur Boost, permettant de lire la
liste de stratégie comme n'importe quel autre tableau dans
~ParametersManager~.

Il serait possible de définir directement dans ~ParametersManager~ le
~ControlPicker~ sans avoir à passer par une liste de
~ControlPickStrategyName~, mais j'ai préférer laisser aux classes
ayant besoin de ~ControlPicker~ décider de comment l'instancier. Ceci
évite de devoir se retrouver avec un ~ControlPicker~ dans la signature
de nombreuses fonctions n'en ayant pas besoin. L'avantage est qu'il
sera plus simple de définir une liste de stratégies, et donc un
~ControlPicker~, différents pour plusieurs trajectoires, ce qui est
envisagé pour la suite.

*** Pourquoi

L'objectif premier de l'approche par stratégie était de ne pas avoir à
définir un algorithme complet pour chaque besoin que pourrait avoir un
utilisateur. Il n'est bien sûr pas possible de prévoir à l'avance tous
les besoins que pourrait avoir un utilisateur, ce mécanisme lui permet
alors de définir son propre algorithme. De plus, comme l'utilisateur
écrit une stratégie, il sera possible de composer celle-ci avec des
algorithmes déjà existants s'il le souhaite.

** Création de ViabiBitSetTrajectoryHelper

Une classe ~ViabiBitSetTrajectoryHelper~ a été créée sur le modèle de
~ViabiMicroMacroTrajectoryHelper~. Cette classe isole la logique de
calcul de trajectoire de la logique du calcul de noyau de viabilité.

La raison de sa création, autre que la cohérence entre les interfaces
des deux types de noyau de viabilité, est que la création de
paramètres de trajectoire a rendu impossible le stockage des fonctions
~controlWeight~ et surtout ~indexSorter~ dans ~SysDyn~. En effet, les
valeurs de ces deux pointeurs de fonctions sont différentes pour
chaque calcul de trajectoire dans le cas de la création de "paramètres
de trajectoire". (Au final seul ~indexSorter~ a une valeur différente à
chaque trajectoire, voir la section suivante.) Déplacer cette logique
dans les classes ~Trajectories~ était difficile car les classes de
trajectoires marchent par paire (on déplace dans la
discrète, la continue, les deux ?) et l'initialisation des classes
trajectoires se faisait à des moments dans le code où l'accès au
paramètres de trajectoire était difficile. La meilleure solution
que j'ai pu trouver est de déplacer cette logique dans les classes
~TrajectoryHelper~. Il y a un sens pour la classe de calcul de
trajectoire de conserver l'information de l'ordre des contrôles. Le
problème étant que seul une classe ~ViabiMicroMacroTrajectoryHelper~
était définie, j'ai donc défini son équivalent pour les problèmes
"~BitSet~".

** Création des paramètres de trajectoire
*** Quoi

Il est possible de définir une liste de paramètres de
trajectoire. Dans le fichier de configuration JSON, les paramètres de
trajectoires sont un tableau d'objets dont la clé est
"~TRAJECTORY_PARAMETERS~". Pour chaque objet dans la liste, une
trajectoire sera tracée. Les paramètres de trajectoires principaux
sont leur point de départ, leur durée et leur type. Ces informations
étaient avant séparée parmi les différents paramètres. D'autres
paramètres existent également pour des algorithmes qui ont besoin de
paramétrisation (un contrôle initial, la taille et le type de bulle
pour les trajectoires prudentes, etc.).

Les fichiers de configurations JSON ne sont à partir de maintenant
plus rétro-compatibles. Certains paramètres ont changé de noms
(passage de singulier à pluriel pour ~INIT_POINTS -> INIT_POINT~ par
exemple).

*** Comment

Beaucoup de changements ont été opérés au niveau des structures de
paramètres. Une structure ~trajectoryParams~ a été créée, possédant
les informations listées ci-dessus. ~ParametersManager~ possède
maintenant un vecteur de ~trajectoryParams~, qu'il remplira avec ces
nouvelles valeurs.

Une trajectoire n'a que besoin de connaître ses propres
paramètres. J'ai donc créé une classe ~TrajectoryParametersManager~
ayant la même interface que ~ParametersManager~ mais qui ne donne pas
la liste complète des paramètres de trajectoire, seulement les
paramètres de la trajectoire dont l'indice a été donné à sa
construction.

Plusieurs paramètres qui étaient précédement globaux pour toutes les
trajectoires tracés sont maintenant individuels grâce à la liste de
paramètres de trajectoire. Par exemple, il est possible de tracer des
trajectoires avec des durées différentes.

*** Pourquoi

L'objectif de la séparation est de pouvoir tracer en une exécution de
Viablab des trajectoires dont tous les paramètres peuvent être
spécifiées individuellement. On peut ainsi regarder par exemple
l'influence de l'algorithme choisi, l'influence de la pondération sur
les contrôles en tracant toutes les trajectoires en une exécution de
Viablab, et donc en évitant de devoir réécrire le JSON à chaque
nouvelle trajectoire souhaitée.

Les paramètres de trajectoire ont également permi de raffiner le
fichier de paramètrage JSON. Certains paramètres étaient avant des
paramètres globaux à toutes les trajectoires alors qu'il n'avaient pas
besoin de l'être. De plus, il est maintenant plus clair de savoir
quels paramètres influencent la trajectoire.

*** Modifications des définitions de fonctions en lien avec la personnalisation de chaque trajectoire

Lors de l'ajout de paramètres de trajectoire, je me suis posé la
question des fonctions de pondération de contrôle et de définition de
la bulle. Ces deux paramètres sont également des paramètres de
trajectoire, mais le souci est que ce sont des fonctions. Ces
fonctions sont donc stockées dans le modèle et non pas dans le
JSON. De plus, ces deux paramètres pourraient également changer pour
chaque stratégie. Il faut donc un moyen pour l'utilisateur de donner
une pondération et une forme de bulle différente selon la trajectoire
calculé et la stratégie utilisée.

Il y avait alors plusieurs possibilité:
1. On ajoute à la signature de la fonction de pondération de contrôles
   les indices de la trajectoire calculée et de la stratégie.
2. On crée une nouvelle fonction par trajectoire, que l'on peut
   optionnellement ranger dans un tableau de pointeurs de fonctions.
3. On crée une fonction renvoyant un pointeur de fonction selon les
   indices de trajectoire et de stratégie données.

La première option correspond à une fonction de pondération de cette
forme:

#+begin_src C++
    double controlWeight(const double *x, const double *u, double t,
                         int indiceTrajectoire, int indiceStrategie) {
        if (indiceTrajectoire == 0) {
            // Pondération pour la première trajectoire
        }
        else if (indiceTrajectoire < 10 && indiceStrategie > 2) {
            // Pondération pour les trajectoires 2 à 10,
            // uniquement pour les stratégies après la 3ème
        }
        else /*...*/
    }
#+end_src

Il est possible pour l'utilisateur de définir ainsi la pondération
comme il le souhaite, mais les pondérations pour chaque trajectoires
sont toutes dans la même fonction. Il serait alors plus "propre"
(séparation des responsabilités) de séparer en fonctions chaque
pondération et de créer un moyen de récupérer la bonne
fonction. L'option 2 correspond à ceci:

#+begin_src C++
  double controlWeight0(const double *x, const double *u, double t) {
      /* ... */
  }

  double controlWeight1(const double *x, const double *u, double t) {
      /* ... */
  }

  // controlWeight_t est défini avec
  // using controlWeight_t = double (*)(const double *, const double *, double)
  controlWeight_t controlWeightArray[NB_TRAJECTORIES][NB_STRATEGIES] = {
      {controlWeight0, controlWeight1, /* ... */},
      {controlWeight1, controlWeight1, /* ... */},
      /* ... */
  };

  /* ... */
#+end_src

Le problème de cette seconde option est que si le nombre de
trajectoires et/ou le nombre de stratégies est grand, mais que l'on
souhaite simplement utiliser la même fonction la plupart du
temps. Dans ce cas, le tableau sera inutilement grand et long à écrire
alors qu'il contient toujours la même valeur dans chaque case. De
plus, pour un utilisateur connaissant moyennement la syntaxe du C, le
tableau de pointeur de fonctions sera possiblement difficile à
comprendre.

Une manière de répondre à ces deux problèmes est d'utiliser une
fonction au lieu d'utiliser un tableau. On a alors les avantages des
deux premières option. Cette fonction renvoie un pointeur de fonction
pour chaque pondération voulue. La troisième option est donc:

#+begin_src C++
  double controlWeight0(const double *x, const double *u, double t) {
      /* ... */
  }

  double controlWeight1(const double *x, const double *u, double t) {
      /* ... */
  }

  controlWeight_t getControlWeightFunction(int trajectoryIndex, int strategyIndex) {
      if (indiceTrajectoire == 0) {
          return controlWeight0;
      }
      else if (indiceTrajectoire < 10 && indiceStrategie > 2) {
          return controlWeight1;
      }
      else /*...*/
  }
#+end_src

Cette option, bien qu'elle sépare correctement le choix de la fonction
et les pondérations elles-même, et qu'elle évite d'avoir à écrire du
code inutile si l'on veut toujours la même pondération, possède un
autre problème. L'utilisateur peut possiblement éprouver des
difficultés à manipuler des pointeurs de fonctions. On a donc décidé
de rester sur la première option, qui mène à l'écriture de code moins
propre mais réduisant les risques d'incompréhension.

J'ai cependant fait le choix de conserver pour chaque paramètre de
trajectoire un pointeur de fonction sur la pondération de contrôle et
la forme de bulle (bien que ce champ soit identique pour chaque
trajectoire dans la version actuelle de la librairie). Ceci devrait
permettre de changer facilement d'implémentation vers les options 2
ou 3.

*** Déplacement de logiques de trajectoire

Le fait que la valeur de l'indice de trajectoire et de l'indice de
stratégie doivent être donné en paramètre à plusieurs fonction de
l'utilisateur a mené à la modification de nombreuses signatures de
fonctions. La classe ~ControlPickStrategy~ doit maintenant connaître
son indice dans la liste de trajectoire. En effet, si l'utilisateur
crée une stratégie personnalisée qui nécessite la fonction de
pondération des contrôles, il faut que cette stratégie utilisateur
puisse également dire quel pondération utiliser (quel indice de
trajectoire et de stratégie donner).

~ViabiBitSetTrajectoryHelper~ a été créé pour pouvoir conserver
l'information de la pondération pour chaque trajectoire. Puisque j'ai
souhaité conserver la possibilité d'avoir une fonction de pondération
différente par trajectoire, la logique de la préférence de contrôle
ne pouvait plus être gérée par ~SysDyn~.
~ViabiMicroMacroTrajectoryHelper~ était un bon candidat pour
les trajectoires Micro-Macro, à quelques modifications près, car cette
classe est ré-initialisée pour chaque trajectoire, donc elle pouvait
conserver cette information changeante à chaque trajectoire. De plus,
le fait que la logique de pondération de contrôle utilisée pour le
calcul trajectoire se trouve dans la classe calculant la trajectoire
paraît naturel. Cependant, cette classe n'avait pas d'homologue pour
les problèmes "~BitSet~", j'ai donc décidé de créer
~ViabiBitSetTrajectoryHelper~

** Création de la classe ControlPickCriteria

La classe ~ControlPickCriteria~ est une classe ayant pour objectif de
regrouper toutes les informations et opérations dont pourrait avoir
besoin une stratégie afin de choisir sa paire (contrôle, pas de
temps). Elle contient donc toutes les informations sur la trajectoire,
sur le ~ControlPicker~ contenant les stratégies (utile pour la
stratégie de bulle), sur les dimensions du problème, sur les
contrôles, sur le pas de temps et sur l'indice de la stratégie et de
la trajectoire calculée. Elle possède de plus des méthodes permettant
d'effectuer des tests simples sur le contrôle afin de prendre une
décision (s'il est viable, s'il mène à une position de grille
identique, etc.).

Cette classe est initialisée par le ~ControlPicker~ du problème pour
chaque stratégie dans la méthode ~pickControlFromSubPickerList~.

L'objectif de cette classe était d'avoir une classe plus simple à
manipuler pour l'utilisateur qui définirait ses propres stratégies (en
évitant d'avoir une méthode pickControl avec une dizaine de paramètres
en entrée) et pour simplifier le développement des stratégies pré-définies.

** Utilisation de final dans les classes héritant de Viabi et Grid

Utiliser ~final~ permet des éventuelles optimisations du compilateur
et n'a aucune influence sur le code. Je l'ai donc ajouté.

** Fonctionnalité de contrôle temporel

*** Quoi

La fonctionnalité de contrôle temporel est développée sous la forme
d'une stratégie nommée "~TEMPORAL_CONTROL~". La stratégie de contrôle
temporel cherche à questionner une fonction définie par l'utilisateur
dont la signature est ~void temporalControl(double t, int trajIndex,
int stratIndex, double *control)~. Celle-ci prend en entrée le temps
depuis le début de la trajectoire. Elle prend également en entrée les
indices de la trajectoire et de stratégie (comme les autres fonctions
utilisateurs). Son dernier paramètre est un tableau de taille
"~CONTROL_DIMENSION~" dans lequel l'utilisateur inscrit le contrôle
voulu au temps donné en entrée.

*** Comment

Le contrôle utilisateur est demandé par la stratégie
"~TEMPORAL_CONTROL~" lorsque celle-ci n'a pas reçu en entrée une paire
(contrôle, pas de temps). La librairie ne travaille cependant qu'avec
des indices dans le tableau de contrôles et non pas les contrôles
eux-même (pour les stratégies cherchant un contrôle proche ou un
contrôle dans un ordre utilisateur, ceci est nécessaire). Le contrôle
de l'utilisateur est donc transformé en indice en trouvant l'indice du
contrôle dont la représentation vectorielle est la plus proche selon
la distance euclidienne entre les deux vecteurs de contrôle.

*** Remarques

Le contrôle temporel aurait pu être implémenté à l'aide de la
pondération sur les contrôles. En effet, avoir un ordre total implique
nécessairement avoir un contrôle préféré.

De plus, la proximité dans le tableau des contrôles est choisi par
distance euclidienne entre les contrôles, mais elle aurait pu être
choisi en fonction de la distance euclidienne des positions d'arrivée
suite à l'application du contrôle utilisateur. Cette dernière version
aurait probablement donné des résultats plus proche de l'emploi du
contrôle utilisateur tel qu'il est renvoyé par ~temporalControl~, mais
aurait comme inconvénients d'être plus lente et de moins retranscrire
la préférence utilisateur.

En effet, puisque le contrôle choisi dans cette version est "le
contrôle menant à la position la plus proche de la position à laquelle
mène le contrôle utilisateur", ce contrôle sera nécessairement moins
proche du contrôle utilisateur que le contrôle à distance euclidienne
minimale. C'est pour ces deux raisons que j'ai choisi de garder la
version avec le contrôle le plus proche.

** Ajout de l'information dans les fichiers de sortie de la stratégie ayant fait le choix du contrôle
*** Quoi

Il est possible pour une trajectoire par stratégie de préciser si l'on
souhaite que le fichier de sortie contienne l'information de la
stratégie ayant choisi le contrôle. L'information est donnée sous la
forme d'une liste de stratégie avec leur indice séparé par une virgule
en fin de chaque ligne du fichier de trajectoire de la forme :
"NOM_STRATEGIE_1(indice_dans_liste_de_stratégies),NOM_STRATEGIE_2(indice_dans_liste_de_stratégies),...NOM_STRATEGIE_n(indice_dans_liste_de_stratégies)".
Le nom de la stratégie apparaît dans la liste d'indice si la paire
(contrôle, pas de temps) en entrée de stratégie est différente (pas de
temps ou indice de contrôle différent) de la paire renvoyée par la
stratégie.

Cette information est donnée par défaut mais peut être désactivée avec
le paramètre de trajectoire "~SAVE_PICKING_STRATEGY~".

*** Comment

Chaque stratégie possède maintenant un paramètre de nom obtenu avec
une méthode ~getName()~. Cette méthode renvoie pour les stratégies
pré-définies le nom donnée à celle-ci dans le fichier JSON de la
stratégie. Le nom des stratégies utilisateur lui aussi vaut la valeur
donnée dans le JSON. Cette logique de nom pour la stratégie
utilisateur, ne devant pas demander d'action particulière de
l'utilisateur, est réalisée par une classe abstraite
~UserPickStrategy~, héritant de l'interface ~ControlPickStrategy~ et
dont doivent hériter les stratégies utilisateurs.

La logique de l'ajout de la contribution de la trajectoire se fait en
dehors des classes de stratégies. Ceci évite au stratégies de gérer
elle-même cette logique (et donc, à l'utilisateur également). Une
contribution de la classe de stratégie sera supposée dès que l'indice
de contrôle, le pas de temps ou la nature de la stratégie sera
modifiée (c'est-à-dire, un passage d'aucun contrôle à une paire ou
vice-versa).

Pour conserver l'information à inscrire dans le fichier de
trajectoire, pour éviter d'avoir à utiliser énormément de mémoire, la
trajectoire conserve un vecteur de "BitFlag". Une valeur de type
BitFlag est en fait qu'un ~unsigned long long int~. Chaque valeur
BitFlag aura un bit en position ~i~ (dans le sens de l'opération de
bit-shift ~<<i~) valant 1 si la stratégie d'indice ~i~ a constribué au
choix du contrôle.

L'inconvenient de cette méthode est un manque de lisibilité éventuel
et surtout une limitation sur le nombre de trajectoire imposée par la
taille de ~unsigned long long int~. Une valeur de ce type doit selon
le standard être capable de stocker au moins 64 bits. Ceci impose donc
à notre programme de ne pas pouvoir gérer une liste de stratégies de
plus de 64 stratégies. J'ai supposé que si un utilisateur réel avait
besoin de plus de 64 stratégies pour satisfaire son besoin, il est
probable que l'on devrait repenser l'approche par stratégies plutôt
que de chercher à augmenter cette limite. Et dans le pire des cas,
l'utilisateur peut définir sa propre stratégie, n'occupant qu'une
position dans la liste de stratégie ensuite.

*** Pourquoi

L'information de la stratégie ayant choisi le contrôle dans le fichier
de trajectoire permet de mieux comprendre le résultat renvoyé, et donc
d'adapter sa stratégie si le résultat n'est pas satisfaisant par exemple.

La représentation comme une liste à virgule sans espaces dans le
fichier de sortie est pour
permettre à un programme lisant le fichier de toujours conserver
l'espace comme le séparateur entre les colonnes. Il pourra alors
regarder la dernière colonne comme une seule entité distincte des
autres, et séparer selon la virgule si besoin. L'indice est donné avec
la stratégie car il est parfaitement possible d'avoir une liste de
stratégie dans laquelle une même stratégie est utilisée deux fois.

** Proposition de méthodes de conversion dans les paramètres de modèle

Les paramètres de modèles sont maintenant une classe distincte
(~modelParams~, pas en PascalCase par cohérence avec les autres). Ceci
permet une plus grande flexibilité sur la gestion des paramètres de
modèle. En effet, la conversion des chaînes de caractères en types
exploitables peut maintenant se faire au travers de cette classe (au
lieu de devoir être faite dans la fonction ~loadModelData~ par
l'utilisateur).

L'exemple [[Possibilité d'ajouter des paramètres au modèles][de la section sur les paramètres de modèle]] devient alors
(avec un fichier de configuration en JSON identique) :

#+begin_src C++
  #include "../include/utilities.h"
  #include "../include/ParametersManager.h"

  extern "C" {

      double constanteMagique;

      void loadModelData(const ParametersManager *PM)
      {        
          modelParams modelParams = PM->getModelParameters();
          // Conversion faite par modelParams::getDouble
          constanteMagique = modelParams.getDouble("CONSTANTE_MAGIQUE");
      }
      /* Il faut ajouter une fonction dynamics, jacobian...ect. */
   }
#+end_src

Il existe des méthodes de conversion ~getInt~, ~getDouble~,
~getString~ et ~getBool~ (permettant de convertir tous les types
primitifs de JSON, excepté null). En pratique, les méthodes "get..."
utilisent pour la plupart les fonctions "ato..." du langage C.

** Possibilité de donner un tableau dans les paramètres de modèle

Une fonctionnalité qu'a permis la transformation des paramètres de
modèle en une classe est possibilité de pouvoir optionnellement donner
un tableau de paramètres eu lieu d'un seul. Par exemple, en conservant
un exemple proche [[Possibilité d'ajouter des paramètres au modèles][de la section sur les paramètres de modèle]].

#+begin_src javascript
  {
    "GRID_PARAMETERS": {/* à compléter */},
    "CONTROL_PARAMETERS": {/* à compléter */},
    "SYSTEM_PARAMETERS": {/* à compléter */},
    "ALGORITHM_PARAMETERS": {/* à compléter */},
    
    "MODEL_PARAMETERS": {
        "CONSTANTES_MAGIQUES": [2.78, 3.14, 42]
    }    
}
#+end_src

Il peut alors récupérer la valeur dans son modèle en écrivant une
fonction ~loadModelData~ comme suit:

#+begin_src C++
  #include "../include/utilities.h"
  #include "../include/ParametersManager.h"

  extern "C" {

      double constantesMagiques[3];

      void loadModelData(const ParametersManager *PM)
      {        
          modelParams modelParams = PM->getModelParameters();
          modelParams.copyDoubles("CONSTANTES_MAGIQUES", constantesMagiques);
          // le tableau constantesMagiques contient les valeurs 2.78, 3.14, 42
      }
      /* Il faut ajouter une fonction dynamics, jacobian...ect. */
   }
#+end_src

Je voulais initialement me servir de cette fonctionnalité pour le
modèle de gestion collective de lac. Bien qu'elle ne soit au final pas
adaptée, elle permet une plus grande expressivité du fichier de
paramètres qui peut possiblement servir.

En remarque, l'implémentation de cette fonctionalité sur les tableaux
avec le ~property_tree~ de Boost implique également qu'un paramètre
peut être donné comme un objet JSON (donc un ensemble de clés-valeurs)
car un tableau est toujours vu par Boost comme un objet ayant des clés
vides. La copie dans le tableau doit alors se faire selon les valeurs
dans l'ordre des paires clé-valeurs données dans le JSON. Je n'ai pas
testé cette fonctionnalité car ce n'est pas l'utilisation prévue de
mais cela devrait être possible et pourrait permettre de commenter les
paramètres dans le JSON à l'aide de leurs clés car elles sont ignorées
(si cela pouvait s'averer utile).

** Fonctionnalité de trajectoire tychastique
*** Généralités
**** Quoi

Une "trajectoire tychastique" est une trajectoire restant dans le
noyau de viabilité garanti. Cela signifie donc qu'il s'agit d'une
trajectoire dont les contrôles sont des contrôles viable pour toutes
les valeurs de tyché. Il n'est cependant pas possible de tracer les
trajectoires pour toutes les valeurs pouvant être prise par le
tyché. Les trajectoires tychastiques vont donc devoir donner une
réalisation de ce tyché à chaque pas de temps. Contrairement au noyau
de viabilité garanti, il est donc obligatoire de donner une
distribution stochastique aux valeurs des tychés.

**** Comment

En pratique, les trajectoires tychastiques seront des trajectoires par
stratégies comme dans un noyau de viabilité simple. Les stratégies
vont simplement devoir choisir un "contrôle viable garanti" au lieu
d'un simple contrôle viable. Une méthode
~computeGuarantedFunctorTrajectory~ a été ajoutée dans
~ViabiBitSetTrajectoryHelper~. Celle-ci sera automatiquement appelé si
la liste des paramètres de trajectoires est non vide et que la
dimension de l'espace des tychés est positive. Le fonctionnement de
cette méthode est identique à ~computeFunctionTrajectory~, à
l'exception du fait qu'à chaque pas de temps, un tyché est généré pour
déterminer le point suivant de la trajectoire. La gestion du tyché a
demandé la création de classes proches des classes pour les
trajectoires simples, mais devant prendre en compte ce tyché (souvent,
cela se traduit juste en un paramètre supplémentaire). Elles sont
toutes préfixés de ~Tychastic~. Il y a par exemple les classes
~TychasticTrajectory~ et ses classes dérivées,
~TychasticControlPickStrategy~ et ses classes dérivées,
~TychasticControlPicker~ et ses classes dérivées et
~TychasticControlPickCriteria~. Il est à noter que les stratégies n'ont
(actuellement) pas l'information du tyché qui sera choisi en position
courante, et doivent donc choisir un contrôle indépendament du tyché
réellement choisi (donc un "contrôle viable garanti").

*** TychePicker
**** Quoi

La seule classe réellement nouvelle est ~TychePicker~. Celle-ci
possède une seule méthode publique : ~pickTyche~. Cette méthode prend
en entrée la position courante de la trajectoire et le temps, et
renvoie l'*indice* dans le tableau des tychés du tyché choisi. Ce
choix du tyché est défini selon les paramètres de tyché donné par
l'utilisateur (voir la [[Paramètres du JSON][documentation des paramètres]] et le chapitre sur
les [[Création des paramètres de tychés][paramètres de tychés]]).

**** Comment

En pratique, l'indice du tyché est choisi selon le choix de chaque
coordonnée du tyché. En effet, chaque coordonnée de tyché est supposée
ici indépendante des autres. ~pickTyche~ cherche à demander à toutes
les méthodes de chaque indice (stockées dans un tableau de pointeurs
de méthodes) quel indice prendre parmi les points d'une coordonnée
donnée (indice choisi pour chaque coordonnée i entre 0 et
CONTROL_TY_GRID_POINTS[i]-1) et "rassemble" cette information en un
indice de tyché.

Pour pouvoir réaliser ce "rassemblement", il a été supposé que le
tableau de tyché avait une forme particulière (ce que j'ai préféré
éviter pour les contrôles par exemple, préférant chercher l'ensemble
de contrôles sans supposer d'ordre sur sa représentation dans le
programme). En effet, il est impossible de
renvoyer un indice de tyché dans l'ensemble des tychés en choisissant
chaque coordonnée s'il est possible qu'une combinaison de deux
coordonnées n'existe pas (si choisir une valeur en $i$ implique
qu'il est impossible de choisir une valeur en $j$ alors qu'une autre
valeur en $i$ l'autorise).

**** Pourquoi

Le choix de renvoyer un indice au lieu d'une valeur est pour deux
raisons. La première est que renvoyer un indice est plus flexible
(permet de ne renvoyer qu'un nombre au lieu de renvoyer des tableaux,
permet de définir des ordres de parcours sur les tychés, permet de
modifier le tableau sous-jacent tant que l'on modifie pas les valeurs
à l'intérieur, permet de s'assurer que la valeur existe, etc.). La
deuxième est que renvoyer un indice permet par la suite dans la
trajectoire de ne stocker qu'un entier, au lieu d'un tableau de
valeur, ce qui peut représenter un gain de mémoire important. De plus,
cela permet une cohérence de la gestion entre les tychés et les
contrôles.

*** Stratégie first
**** Quoi

La première stratégie tychastique (~TychasticControlPickStrategy~)
implémentée est la stratégie "FIRST". Celle-ci
est assez différente de la stratégie "FIRST" des algorithmes de
viabilité simples dans le sens où elle cherche le premier viable
garanti au lieu du premier viable. C'est-à-dire qu'elle renvoie
l'indice du premier contrôle viable pour toute valeur de tyché en un
point donné.

**** Comment/Pourquoi

La viabilité de ce contrôle est définie à partir la
viabilité du contrôle sur la grille, contrairement à la viabilité dans la
stratégie "FIRST" simple, où l'on cherchait d'abord le premier
contrôle viable de grille, mais où l'on renvoyait le contrôle de la
trajectoire réel permettant de se rapprocher le plus possible du point
d'arrivée de la position de grille. En effet, j'ai pas trouvé de sens
à chercher un contrôle réel permettant de se rapprocher le plus
possible du point d'arrivée de la grille car le point d'arrivée de
grille n'est plus un point mais un ensemble de points. Une solution
aurait pu être de trouver le contrôle réel cherchant à se rapprocher
du barycentre de cet ensemble, mais la stratégie "FIRST" devant être
la plus simple, j'ai préféré éviter de l'implémenter ainsi.

*** Distribution de probabilité
**** Quoi

L'utilisateur peut donner une distribution de probabilité de deux
manières différentes. Il peut la donner sous la forme du fonction de
répartition, dans quel cas le modèle devra contenir une fonction
~double cumulativeDistribution(double tycheValue, int coordIndex,
const double *x, double t, int trajIndex)~. Il peut également la
représenter comme une fonction de densité/de masse
~double probabilityDensity(double tycheValue, int coordIndex, const
double *x, double t, int trajIndex)~. Ces deux fonctions devront donc
renvoyer, pour une position, un pas de temps et un indice de
trajectoire et de coordonnée donné, la valeur de la fonction de
répartition ou de masse en chaque point de tyché.

Il est important que la somme des valeurs prises par la fonction de
densité vale 1, ou que la valeur renvoyée par la fonction de
répartition pour tycheValue = CONTROL_TY_MAX_VALUES[coordIndex]
vale 1. En effet, l'algo permettant de choisir le tyché i selon la
fonction de l'utilisateur est le suivant:

#+begin_example
n <- CONTROL_TY_GRID_POINTS[i]
probabilité_cumulée <- tableau de taille n

Pour chaque valeur de tyché d'indice t:
    probabilité_cumulée[t] = cumulativeDistribution(tyche[t], ...)
    // ou, en initialisant probabilité_cumulée[0] = probabilityDensity(tyche[0], ...)
    probabilité_cumulée[t] = probabilité_cumulée[t-1] + probabilityDensity(tyche[t], ...)
finPour

u <- Valeur réelle générée aléatoirement uniformément entre 0 et 1
t <- 0

// n - 1 car on suppose que la dernière valeur de la probabilité cumulée vaut 1
Tant que probabilité_cumulée[t] <= u et t < n -1 faire:
    t <- t + 1
finTantQue

retourner t

#+end_example

La supposition sur les fonctions de masse et de répartition permet à
l'algorithme de n'avoir à générer qu'une seule valeur aléatoire par
choix par choix de tyché. L'autre solution si la
fonction de répartition ou de masse n'avait pas comme dernière valeur
ou somme 1 était de refaire des tirages de nombres aléatoires jusqu'à
ce que la valeur du tyché soit compris entre les valeurs MIN et MAX,
mais si l'utilisateur donne une fonction de répartition dont les
valeurs obtenues sortent largement du support [MIN, MAX], alors les
tirages peuvent devenir longs.

Il faut donc que la fonction de répartition ou de masse respectent
bien leur contrainte. Une solution pour adapter des fonctions de
répartition ou de masse dont le support est ]-∞, +∞[ est de
"réhausser" les valeurs en multipliant la fonction par un réel de
telle sorte que la somme/l'intégrale vale 1.

** Création de la liste des paramètres de tyché
*** Quoi

La liste des paramètres de tychés est un tableau (au sens du
formalisme JSON) d'objets, que l'on va nommer paramètres de tyché de
longueur "CONTROL_TYCHASTIC_DIMENSION". La liste des paramètres de
tyché a une forme semblable au paramètres de trajectoires. Il s'agit
d'un paramètre des paramètres de trajectoires dont la clé est
"~TYCHASTIC_PARAMETERS~".

Dans l'état actuel, les paramètres de tyché permettent, pour chaque
dimension de l'espace des tychés, de préciser sa distribution (au sens
d'une loi de probabilité) pour le tracé d'une trajectoire. On peut
notamment préciser une distribution de probabilité, donner une valeur
constante au tyché ou encore donner une valeur/distribution variant au
cours du temps à l'aide de fonctions dans le modèle (voir la
[[Paramètres du JSON][description des paramètres tychastiques du fichier de paramètre JSON]]).

*** Comment

La liste des paramètres tychastiques est traduite en une liste de
~struct tycheParams~ contenue dans les paramètres de
trajectoire. Cette liste de paramètres tychastique est ensuite lue par
~TychePicker~ dans son constructeur pour qu'il puisse assigner les
pointeurs de méthodes corrects en fonction des besoins de
l'utilsateur. Il y a au moment de l'écriture de ce texte 5 options de
distribution ("~TYCHE_DISTRIBUTION~" dans le fichier JSON):

- *Uniforme* ("~UNIFORM~" dans le JSON) : le pointeur pour le tyche ~i~
  vaudra ~pickUniformTyche~. Celui-ci choisit un indice choisi
  uniformément parmi [0, "~CONTROL_TY_GRID_POINTS~"[i][ et renvoie
  cette valeur
- *Constant* ("~CONSTANT~" dans le JSON) : le pointeur pour le tyche ~i~
  vaudra ~returnConstantTycheValue~. Celui-ci renvoie l'indice du
  point le plus proche parmi les points de tyché de la valeur choisie
  par l'utiliateur dans le champ "~CONSTANT_TYCHE_VALUE~".
- *Déterminé* ("~CUSTOM_DETERMINED~" dans le JSON) : le pointeur pour le
  tyche ~i~ vaudra ~pickUserTyche~. Celui-ci renvoie l'indice du point
  le plus proche parmi les points de tyché de la valeur choisie
  par l'utilisateur selon une fonction du modèle de signature
  ~double userTyche(const double *x, double t, int coordIndex, int
  trajIndex)~. Cette fonction est supposée "pure" (les mêmes entrées
  impliquent les mêmes sorties).
- *Fonction de répartition* ("~(CONSTANT_)CUMULATIVE_DISTRIBUTION~" dans
  le JSON) : le pointeur pour le tyche ~i~ vaudra  
  ~pickCumulativeDistributionTyche~ (ou
  ~returnCustomlyDistributedTyche~ si ~CONSTANT~). Celui-ci choisit un
  indice de tyché parmi [0, "~CONTROL_TY_GRID_POINTS~"[i][ selon une
  distribution utilisateur définie par une fonction de répartition sur
  les tychés représentée dans le modèle par une fonction de signature
  ~double cumulativeDistribution(double vi, int coordIndex, double *x,
  double t, int trajIndex)~. Si ~CONSTANT~ est précisé, le calcul ne
  sera fait qu'une seule fois en début de trajectoire pour gagner en
  performance si la distribution est invariante en fonction de la
  position de l'espace et au cours du temps.
- *Fonction de masse/de densité* ("~(CONSTANT_)PROBABILITY_DENSITY~" dans
  le JSON) : le pointeur pour le tyche ~i~ vaudra  
  ~pickDensityTyche~ (ou ~returnCustomlyDistributedTyche~ si
  ~CONSTANT~). Celui-ci choisit un
  indice de tyché parmi [0, "~CONTROL_TY_GRID_POINTS~"[i][ selon une
  distribution utilisateur définie par une fonction de masse/de
  densité sur les tychés représentée dans le modèle par une fonction
  de signature ~double cumulativeDistribution(double vi, int
  coordIndex, double *x, double t, int trajIndex)~. Si ~CONSTANT~ est
  précisé, le calcul ne sera fait qu'une seule fois en début de
  trajectoire pour gagner en performance si la distribution est
  invariante en fonction de la position de l'espace et au cours du temps.

Les indices renvoyés par les différentes méthodes sont ensuite
"regroupés" pour obtenir l'indice dans le tableau des tychés.

*** Pourquoi

Représenter les paramètres de tychés comme une liste permet à chaque
dimension de l'espace des tychés d'être indépendante des autres. Ceci
permet à l'utilisateur, par exemple, de ne faire varier qu'une seule
coordonnée de tyché en gardant les autres constantes s'il veut voir
l'influence d'une coordonnée de tyché sur la trajectoire.

Le fait de renvoyer des indices permet une cohérence avec les
contrôles et de s'assurer également que les tychés renvoyés sont bien
des tychés dont la valeur a été utilisée dans le calcul de noyau de
viabilité garanti.

** Correction du chargement de noyaux de viabilité "light"

Le noyau de viabilité chargé par la méthode ~loadViableSet~ des
classes ~ViabiBitSet~ et ~ViabiMicroMacro~ n'était pas chargé
correctement si le noyau a été enregistré avec le paramètre
"~SAVE_VIABSET_LIGHT~" du fichier de configuration JSON à true. Il
supposait en effet que tous les points se trouvaient dans le fichier
de sortie dans l'ordre lexicographique des coordonnées, avec un valeur
indiquant son appartenance dans le noyau de viabilité, ce qui n'est
pas le cas si l'enregistrement s'est fait en "mode light".

Pour corriger cela, j'ai converti les coordonnées réelles dans le
fichier en indices dans le tableau représentant le noyau et assigné la
valeur contenue dans le fichier de sortie à la grille pour donner
l'appartenance au noyau.

** Correction de getStepTy dans SysDyn

La méthode getStepTy retournait limInfTy, alors qu'elle devrait
retourner stepTy.

** Correction de l'initialisation de la méthode de calcul de constante de Lipschitz

Dans l'initialisation des méthodes de SysDyn (~initializeMethods~), la ligne suivante:

#+begin_src C++
  SysDyn::calcul_L = isTychastic ? &SysDyn::calculL_local_ana : &SysDyn::calculL_local_ana;
#+end_src

a été corrigée en

#+begin_src C++
  SysDyn::calcul_L = isTychastic ? &SysDyn::calculL_local_ana_tych : &SysDyn::calculL_local_ana;
#+end_src

** Ajout de la possibilité de réécrire les valeurs par défaut des paramètres de trajectoire et tychastique
*** Quoi

Voir la section sur [[Définition des paramètres de trajectoire et de tyché][les paramètres de trajectoire et tychastique]].

*** Comment

Dans ~ParametersManager~, on cherche le champ correspondant au
paramètres de trajectoire/tyché. Si le premier enfant de l'attribut
existe (donc, que l'attribut existe est une structure de donnée
composée) on regarde si celui-ci possède un attribut
"DEFAULT_VALUES". Si ce n'est pas le cas, on supposera que l'attribut
est un tableau de paramètres de trajectoires classique. Si l'attribut
"DEFAULT_VALUES" existe, on supposera que le champ "DEFAULT_VALUES"
contient les valeurs par défaut que veut l'utilisateur, que l'on place
dans un ~property_tree~ qu'on va nommer ~userDefaults~ et on déplace
la variable donnant la liste des paramètres de trajectoire sur le
champ "..._SPECIFIC_VALUES". Si c'est TRAJECTORY et que le champ
n'existe pas, alors on envoie un log d'erreur et on fait comme s'il
n'y avait pas de paramètres de trajectoire. Si c'est TYCHE, alors on
complète chaque ~tycheParams~ du tableau de longueur
~CONTROL_TYCHASTIC_DIMENSION~ avec les valeurs par défaut de
l'utilisateur uniquement.

Dans toutes ces étapes, si le champ "DEFAULT_VALUES" ne contient pas
un attribut, il sera complété avec la valeur par défaut donnée pour
l'attribut dans la section d'explication des paramètres du JSON.

L'arbre ~userDefaults~ contient donc les paramètres par défaut de
l'utilisateur. Pour prendre en compte ces paramètres dans les arbres
de trajectoire spécifique, ma méthode a été de fusionner l'arbre
~userDefaults~ dans chaque arbre spécifique. Fusionner signifie ici
insérer l'attribut de ~userDefaults~ dans l'arbre spécifique s'il
n'existe pas à l'intérieur de l'arbre spécifique. De plus, pour gérer
les arbres avec des attributs composés, si jamais ~userDefaults~
contient un attribut composé, même s'il existe dans l'arbre
spécifique, alors il faut ajouter récursivement tous
les attributs de cet attribut composé dans l'arbre spécifique. Ainsi,
chaque arbre spécifique est complété des valeurs de l'arbre par défaut
et le code de lecture des paramètres de l'arbre n'est pas à modifier.

Le code de fusion est dans une fonction contenue dans
~ParametersManager.cpp~ de signature ~void mergeJSONPtreeInto(const
ptree &from, ptree &to)~.

** Ajout d'une stratégie de "bord de bulle"
*** Quoi

La stratégie de bord de bulle consiste à renvoyer le contrôle choisi
par les stratégies suivantes au point le plus proche (selon la
distance euclidienne) du point courant situé sur un bord. Elle diffère
donc de la stratégie de bulle classique par le fait qu'aucune
simulation n'est réalisée. On ne s'intéresse ici pas au bord du noyau
de viabilité auquel on va réellement aller, mais plutôt le bord du
noyau de viabilité le plus proche.

Cette stratégie s'utilise avec la stratégie nommée "BUBBLE_BORDER"
dans le JSON.

*** Comment

La stratégie demande à la bulle avec la méthode
~getClosestPointOnBorder~ de trouver le point le plus proche de la
position courante sur un bord du noyau de viabilité. Cette méthode
parcours l'ensemble des points de la bulle à la recherche du point de
distance minimale pour lequel ~isOnBorder~ renvoie vrai.

Ce point est ensuite inséré au bout des simulations discrètes et
réelle de trajectoire, afin de simuler au autres stratégies une
arrivée sur ce point. On demande ensuite au picker d'interroger les
stratégies suivante pour déterminer quel serait le contrôle pris en ce
point. Ce dernier est retourné tel quel par la stratégie.

*** Pourquoi

L'objectif de cette stratégie est de pouvoir dans certains cas éviter
les problèmes de tremblottement de la stratégie de bulle classique si
jamais la raison de ce tremblottement est une dynamique qui aurait des
problèmes à atteindre le bord du noyau même si la bulle le
touche. Ceci peut être dû à une dynamique qui approcherait lentement
le bord du noyau de viabilité (à cause de son orientation qui la
rapproche lentement du bord, ou de sa vitesse lente causant une
simulation dépassant le nombre d'itérations maximal).

Un autre objectif qui a mené à son implantation tardive est que
celle-ci, contrairement à la stratégie de bulle classique, peut être
utilisée dans le cas d'une trajectoire garantie. En effet, regarder le
point le plus proche du bord du noyau de viabilité garanti peut se
faire indépendamment de la valeur des tychés futurs.

** Gestion de la contrainte état-tyché dans TychePicker

Le respect de la contrainte ~constraintsXV_tych~ dans la classe
~TychePicker~, qui choisit les tychés individuellement sur chaque
coordonnée, n'a pas été évident. En effet, pour déterminer selon cette
fonction l'invalidité d'un tyché, il faut avoir "construit" le tyché
complet. Or, ~TychePicker~ cherche à construire le tyché coordonnée
par coordonnée. Il a donc fallu trouver un moyen de s'assurer que le
tyché final respectait les contraintes.

Pour cela, j'ai choisi de générer un premier tyché sans prendre en
compte la contrainte. Si ce tyché ne respecte pas la contrainte, alors
on choisira à nouveau une coordonnée parmi les "coordonnées
non-déterministes". Ce que j'appelle coordonnées "non-déterministes"
sont celle qui ont été décidée avec une distribution de tyché parmi
"UNIFORM", "(CONSTANT_)CUMULATIVE_DISTRIBUTION" ou
"(CONSTANT_)PROBABILITY_DENSITY". En particulier, les tychés "CONSTANT"
et "CUSTOM_DETERMINED" seront supposés inchangeables. Si tous les tychés
sont soit CONSTANT, soit "CUSTOM_DETERMINED" et que le tyché choisi ne
respecte pas la constrainte ~constraintsXV_tych~, alors le programme
s'arrêtera.

Lorsqu'on a plusieurs coordonnées non déterministes, le tyché sera
tiré à tour de rôle sur chaque coordonnée.

Par exemple, supposons que
l'on ait un espace des tychés en 4 dimensions. De plus, supposons que
seul la troisième dimension est "CONSTANT" et que ~TychePicker~ ait
tiré un tyché $V_1 = (v_1, v_2, v_3, v_4)$ non conforme selon
~constraintsXV_tych~. Alors, les tychés confrontés à la contrainte
suivants auront comme valeurs:

- $V_2 = ({v_1}', v_2, v_3, v_4)$
- $V_3 = ({v_1}', {v_2}', v_3, v_4)$
- $V_4 = ({v_1}', {v_2}', v_3, {v_4}')$ (car v_3 a été choisi selon une méthode "CONSTANT", donc déterministe).
- $V_5 = ({v_1}'', {v_2}', v_3, {v_4}')$
- $V_6 = ({v_1}'', {v_2}'', v_3, {v_4}')$
...

Le premier parmi les $V_i$ qui respecte la contrainte aura son indice
retourné par ~TychePicker::pickTyche~. Une tableau ~int *
TychePicker::MAX_NB_REROLLS~ determine le nombre de fois où ceci sera
testé pour chaque coordonnée avant d'arrêter le programme (pour éviter
une boucle infinie dont le sens serait opaque pour l'utilisateur). Sa
valeur par défaut est 10 pour chaque tyche mais elle peut être
modifié avec le paramètre de trajectoire ~MAX_NB_REROLLS~ dans
les ~TYCHE_PARAMETERS~. Elle a été définie pour chaque tyché car il
est possbile qu'un tyché prenne par exemple 2 valeurs ou qu'un tyché
ait une valeur bien plus probable que d'autres et que le tirer un
grand nombre de fois n'a pas beaucoup de sens. Si le nombre de tirage
pour une coordonnée i a atteint la valeur de ~MAX_NB_REROLLS[i]~,
alors la coordonnée ne sera plus modifié pour les tirages à venir
(elle sera ignorée, comme si elle était maintenant constante).

La transformation utilisée pour changer la coordonnée d'un point
lui-même transformé en entier est décrite dans la section ci-dessous.

**** Modification d'une coordonnée

Supposons que l'on ait un point $x = (x_0, x_1 \dots x_{n-1})$ avec
$x_i$ la coordonnée du point sur une dimension donnée (on part de
l'indice 0 pour se rapprocher de l'implémentation) et $n$ la dimension
de l'espace d'état.

Ce point $x$ est transformé en entier de la manière suivante:

$\overline{x} = \sum_{k=0}^{n-1}{x_k\prod_{l=k+1}^{n-1}{nbPoints[l]}}$

Pour simplifier l'écriture, je vais noter $\prod_{k}^{n} =\prod_{l=k}^{n}{nbPoints[l]}$

On a donc que $\overline{x} = \sum_{k=0}^{n-1}{x_k\prod{k+1}^{n-1}}$

L'objectif est de remplacer dans cette écriture la coordonnée $x_m$
par $x_m'$. On a que $x_m = \lfloor
\frac{\overline{x}}{\prod{k+1}^{n-1}} \rfloor mod nbPoints[k]$. avec
"mod" l'opération modulo sur les entiers.

Donc, pour remplacer $x_m$ par $x_m'$, on fait:

$\overline{x'} = \overline{x} - \prod_{k+1}^{n-1}\left( x_m' - x_m
\right)$ avec $x_m$ valant l'expression ci-dessus.

** Amélioration de la robustesse de la stratégie du premier viable garanti

Au lieu de prendre simplement le contrôle et le pas de temps de grille
en position réelle, la stratégie cherche également à diminuer le pas
de temps pour chercher si le contrôle est viable. Si le contrôle
amène, pour tout tyché, en la même position de grille, on supposera
que le contrôle n'est pas viable. En effet, si la position de grille
est identique entre 2 pas de temps, alors le contrôle et le pas de
temps de grille aussi, donc le contrôle n'a que peu de chance de
devenir viable à l'itération suivante (le seul cas que j'envisage est
le cas d'une dynamique telle que le schéma numérique réalise une
erreur de reconstruction menant à un autre point de grille que
plusieurs pas de temps depuis une mène position initiale).

** Création de trajectoire vide dans la stratégie de bord de bulle au lieu d'une simulation

Initialement, la stratégie BUBBLE_BORDER utilisait des simulations de
trajectoires dans lesquelles elle plaçait le point au bord avec un
contrôle (et éventuellement un tyché) d'indice 0 pour que les
stratégies suivantes de la liste prennent comme position courante dans
leur calcul le point de bord. Cette approche ne fonctionne que pour
les stratégies ne regardant que le dernier point de la
trajectoire. Or, SMOOTH regarde l'historique des deux derniers points
de la trajectoire et cherchait à lisser une trajectoire dont les deux
derniers points n'ont aucun lien autre que leur proximité dans
l'espace d'état, et donc ne fonctionnait pas correctement.

Pour corriger cela, la stratégie de bord de bulle crée maintenant une
trajectoire avec un seul point: le point de bord de bulle. Il n'y a
donc plus d'historique et les stratégies regardant celui-ci ne
renverront pas des résultats incohérents.

** Séparation des stratégies garanties et non-garanties

Dans le cas d'une trajectoire tychastique, il m'a semblé incohérent de
chercher à composer des stratégies ayant la connaissance du contrôle
courant avec des stratégies ne l'ayant pas et devant donc choisir une
contrôle viable garanti (viable pour tout tyché). J'ai donc séparé ces
deux types de stratégies dans la classe ~TychasticControlPickerBitSet~
au travers de deux méthodes ~addNonGuaranteedStrategies~ et
~addGuaranteedStrategies~. Le choix de la méthode employé est dicté
par le paramètre de trajectoire "~ARE_STRATEGIES_GUARANTEED~". En
pratique, en fonction de ce paramètre, les pointeurs des méthodes dans
~TychasticControlPickCriteria~ définissant des algorithmes utilisés
pour les stratégies sont modifiés pour utiliser un algorithme
vérifiant une condition pour tous les tychés ou un seul tyché.

J'aurai pu isoler plus ces deux types de stratégies (en réalisant deux
sous-classes par exemple), mais n'étant pas sûr que cette séparation
ait de sens, et leurs comportements étant souvent identique à
l'utilisation de méthodes garanties ou non près, ces deux types de
stratégies sont toujours composables. Une liste de stratégies
contenant stratégies garanties et non-garanties est seulement interdit
par la structure du fichier de configuration JSON ne permettant pas de
les composer.

** Utilisation de std::invoke

La syntaxe d'appel de pointeurs de méthode en C++ est très dure à
utiliser et n'est pas très lisible. C'est pour cette raison que
j'utilise ~std::invoke~ à plusieurs endroits pour remplacer cette
syntaxe.

* Propositions, changements futurs
** Simplification de fonctions
*** Grid_BitSet::saveValOnGrid[Light]

Créer une méthode pour sauvegarder un point en version light et non light:
#+begin_src C++
void Grid_BitSet::saveCoord(ofstream &fichierB, double *xCoordsDouble) {

    for (int l1 = 0; l1 < dim; l1++)
    {
        fichierB << xCoordsDouble[l1] << " ";
    }
    
    if ((*gridTab[posX])[k])
    {
        fichierB << "1.0 \n";
    }    
    else
    {
        fichierB << "0.0 \n";
    }
}

void Grid_BitSet::saveCoordLight(ofstream &fichierB, double *xCoordsDouble) {
    if ((*gridTab[posX])[k])
    {
        for (int l1 = 0; l1 < dim; l1++)
        {
			fichierB << xCoordsDouble[l1] << " ";
        }
        fichierB << "1.0 \n";
    }
}
#+end_src

Créer une méthode ~saveValOnGridCommon~ prenant en argument une
méthode avec la signature des précédentes:

#+begin_src C++
    void Grid_BitSet::saveValOnGridCommon(string filename, void (Grid_BitSet::*saveCoord)(ofstream &, double *))
    {
      //cout<<"ecriture  de l'ensemble dans un fichier \n";
      // instructions

      unsigned long long int indice[dim - 1];
      double xCoordsDouble[dim];
      ofstream fichierB(fileName.c_str());

      if (fichierB)  // si l'ouverture a r�ussi
      {

      //        cout<<"dim etat  " <<dim<< " taille de trame est " <<nbPointsTotalSubGrid<<"\n";

      for (unsigned long long int posX = 0; posX < nbPointsTotalSubGrid;
          posX++)
          {
          //cout<< " posx = "<<posX<<endl;
          numToIntCoords_gen(posX, dim - 1, nbPointsSubGrid, indice);

          for (int j = 0; j < dirTramage; j++)
          {
          xCoordsDouble[j] = limInf[j] + indice[j] * step[j];
          }

          for (int j = dirTramage + 1; j < (int) dim; j++)
          {
          xCoordsDouble[j] = limInf[j] + indice[j - 1] * step[j];
          }

          for (unsigned long long int k = 0; k < longTrame; k++)
          {
          xCoordsDouble[dirTramage] = limInf[dirTramage]
                             + k * step[dirTramage];

          saveCoord(fichierB, xCoordsDouble);
          }
          }  // fin de for de parcours de la trame
      fichierB.close();
      // je referme le fichier
      }
      else
      // sinon
      cerr << "Erreur � l'ouverture !" << endl;
  }
#+end_src

Remplacer le code de saveValOnGrid[Light] par:

#+begin_src C++
  void Grid_BitSet::saveValOnGrid(string fileName)
  {
      saveValOnGridCommon(filename, saveCoord);
  }

  void Grid_BitSet::saveValOnGridLight(string fileName)
  {
      saveValOnGridCommon(filename, saveCoordLight);
  }
#+end_src

*** Grid_BitSet::intCoordsToNum_dm1

Remplacer

#+begin_src C++
  if (dirTramage > 0)
  {
      (*res) = coords[0];
      int i = 0;
      while (i < (int) dirTramage - 1)
      {
          (*res) = (*res) * nbPointsSubGrid[i + 1] + coords[i + 1];
          i++;
      }
      i = dirTramage;
      while (i < dim - 1)
      {
          //cout <<"  i="<<i<<endl;
          (*res) = (*res) * nbPointsSubGrid[i] + coords[i + 1];
          i++;
      }
      //cout<< "  res = "<<*res<<endl;
  }
  else
  {
      (*res) = coords[1];
      //cout<< " dir tramage est  "<<dirTramage<<endl;

      //cout<< "  res = "<<*res<<endl;
      int i = 1;

      while (i < dim - 1)
      {
          //cout <<"  i="<<i<<endl;
          (*res) = (*res) * nbPointsSubGrid[i] + coords[i + 1];
          i++;
      }
      //cout<< "  res = "<<*res<<endl;
  }
#+end_src

par

#+begin_src C++
  if (dirTramage > 0)
  {
      (*res) = coords[0];	
  }
  else
  {
      (*res) = coords[1];
  }

  for (int i = 1; i < dirTramage; ++i)
  {
      (*res) = (*res) * nbPointsSubGrid[i] + coords[i];
  }

  for (int i = dirTramage; i < dim - 1; ++i)
  {
      //cout <<"  i="<<i<<endl;
      (*res) = (*res) * nbPointsSubGrid[i] + coords[i + 1];
  }
  //cout<< "  res = "<<*res<<endl;
#+end_src
** Modification de la prise en compte du nombre de threads OMP

Pour l'instant il est nécessaire de préciser le nom de la librairie et
du JSON (ce dernier étant optionnel) avant de pouvoir donner le nombre
de threads OMP.

** Autres stratégies de calcul de trajectoire qui pourraient être utiles

- Stratégie effectuant un "retour en arrière" (dans le sens retour
  dans le temps) lorsqu'on atteint un
  bord, puis cherchant un autre contrôle depuis le point auquel on est
  retourné. Ceci pourrait nécessiter une modification de la
  trajectoire par les Pickers, impossible pour l'instant.  
- Stratégie choisissant le contrôle éloignant toujours la position
  courante du bord.
- Possibilité de création de stratégies par l'utilisateur

** Regroupement du modèle et du JSON

La proposition suivante n'est faite qu'à titre indicatif. Ceci
nécessiterait du temps à implémenter, temps que je réserve pour
d'autres activitées. Mais je pense que ceci permettrait une
utilisation plus simple de la librairie et je la laisse dans ce
fichier à titre de rappel et de proposition pour un(e) futur(e)
developpeur(se).

L'objectif serait de regrouper les JSON et les modèles en un seul
fichier qui pourrait contenir et les paramètres, et le
modèle. Ceci devrait être fait à mon avis sous les conditions
suivantes:

1. Ne pas avoir à recompiler à chaque changement de paramètre du JSON
   le code C++
2. Ne pas (trop) perdre en performance par rapport au fonctions
   utilisateur C du modèle initial
3. Ne pas introduire plus de complexité pour l'utilisateur

La première condition implique ne pas mettre tous les paramètres dans
le modèle en langage C (recompiler à chaque changement serait
inbuvable). Il existe des méthodes pour [[https://www.softintegration.com/][compiler du C++ à la volée]],
qui pourraient possiblement palier à ce point, mais je ne les maîtrise
pas et ne connaît pas l'intégration qui peut en être faite avec du C++
compilé (même s'il est annoncé que c'est faisable, je ne sais pas si
c'est simple).

Une autre solution est d'utiliser [[https://luajit.org/luajit.html][LuaJIT]] qui a été pensé pour
permettre l'intégration avec du C/C++. Le langage Lua, qui est compilé
et interprété par la librairie serait plus facilement abordable pour
un utilisateur de la librairie que du C++. Un plan d'expérience du
modèle d'accroissement de population pourrait par exemple en Lua être
écrit ainsi:

#+begin_src lua
    -- Je suis un commentaire en Lua
    --[[Je suis un
       commentaire multi-lignes ]]


    -- Toutes les variables ci-dessous sont accessible en C++

    -- parameters

    -- Les tables existent nativement en Lua
    algorithm_parameters = {
       -- : du JSON indiquant une paire clé-valeur à remplacer par un =
       "COMPUTE_MIN_TIME" = false,
       "COMPUTE_VIABLE_SET" = true,
       "GRID_REFINMENTS_NUMBER" = 0,
       -- Crochet [] de JSON à transformer en {}
       "INTERMEDIATE_SAVINGS" = false,
       "ITERATION_STOP_LEVEL" = 0,
       "LEVEL" = 1,
       "NUMBER_OF_TRAJECTORIES" = 1,
       "PROJECTION_AXIS" = {
          1,
          0
       },
       "SAVE_BOUNDARY" = true,
       "SAVE_PROJECTION" = false,
       "SAVE_SLICE" = false,
       "SAVE_SLICE_BOUND" = false,
       "SAVE_SUBLEVEL" = false,
       "SAVE_VIABSET_LIGHT" = false,
       "SET_TYPE" = "VIAB",
       "TARGET_OR_DEPARTURE" = "DEPARTURE"
    };

    control_parameters = {
       "CONTROL_DIMENSION" = 1,
       "CONTROL_GRID_POINTS" = {
          100
       },
       "CONTROL_MAX_VALUES" = {
          0.5
       },
       "CONTROL_MIN_VALUES" = {
             -0.5
       }
    };

    grid_parameters = {
       "GRID_MAIN_DIR" = 0,
       "GRID_METHOD" = "BS",
       "LOWER_LIMIT_IS_NOT_CONSTRAINT" = {
          0,
          0
       },
       "OUTPUT_FILE_PREFIX" = "SimplePopGrowth",
       "SLICE_DIRECTIONS" = {
          0,
          0
       },
       "SLICE_LEVELS" = {
          1,
          1
       },
       "SLICE_LEVELS_DISCRETE" = {
          0,
          0
       },
       "STATE_DIMENSION" = 2,
       "STATE_GRID_POINTS" = {
          1001,
          1001
       },
       "STATE_MAX_VALUES" = {
          3,
          2
       },
       "STATE_MIN_VALUES" = {
          0.2,
          -2
       },
       "STATE_PERIODIC" = {
          0,
          0
       },
       "UPPER_LIMIT_IS_NOT_CONSTRAINT" = {
          0,
          0
       }
    };

    system_parameters = {
       "DYNAMICS_TYPE" = "CC",
       "DYN_BOUND" = 1,
       "DYN_BOUND_COMPUTE_METHOD" = "NUMERICAL_CALC",
       "IS_TIMESTEP_GLOBAL" = false,
       "LIPSCHITZ_CONSTANT" = 1,
       "LIPSCHITZ_CONSTANT_COMPUTE_METHOD" = "NUMERICAL_CALC",
       "TIME_DISCRETIZATION_SCHEME" = "RK4",
    };

    trajectory_parameters = {{
       "INITIAL_POINT" = {1.1, 0.9},
       "TRAJECTORY_TYPE" = "CAUTIOUS",
       "BUBBLE_RADIUS" = 1,
       "TRAJECTORY_TIME_HORIZON" = 10,
    }, {
       "INITIAL_POINT" = {1.1, 0.9},
       "TRAJECTORY_TYPE" = "CAUTIOUS",
       "BUBBLE_RADIUS" = 1,
       "TRAJECTORY_TIME_HORIZON" = 10,
       -- Possibilité de lire une fonction de pondération, de forme de bulle etc.
       -- différente par trajectoire     
       "controlWeight" = function (x, u, t) return u[1]; end,
    }};

    -- Model

    -- Définition d'une fonction en Lua
    -- Lua est typé dynamiquement
    function dynamics(x, u, image)
       --[[ Accessible comme des arrays C, grâce à la redéfinition d'une méta-méthode lua
          La convention Lua veut que ces valeurs s'accèdent en commençant à 1,
          mais l'indiçage à partir de 0 est toujours possible
          puisque l'on réalise nous-même la fonction d'indiçage en C.
          Les valeurs x, u et image sont des objets lua qui manipulent le tableau C,
          l'indirection permet leur manipulation, et donc l'indiçage, comme on le souhaite. ]]
       image[1] = x[1]*x[2];
       image[2] = u[1];
    end

    function jacobian(x, u, jacob)
       jacob[1][1] = 0;
       jacob[1][2] = 0;
       jacob[2][1] = 0;
       jacob[2][2] = 0;
    end

    function localDynBounds(x, bound)
       bound[1] = 0;
       bound[2] = 0;
    end

    function controlWeight(x, u, t)
       -- Valeur de retour possible
       if x[1] > 1.5 then
          return -u[1];
       else
          return u[1];
       end
    end
#+end_src

#+RESULTS:

Ces valeurs peuvent être lues par le code C++ suivant:

#+begin_src C++
  #include "lua.hpp" // Import pour utiliser luajit

  void exemple() {

      // Nouvel état
      lua_State *L = luaL_newstate();

      // Lecture du fichier (à faire une fois au début du code C++)
      if (luaL_dofile(L, "nom_du_fichier.lua") != LUA_OK) {
          luaL_error(L, "Une erreur a empêché l'ouverture du fichier : %s\n", lua_tostring(L, -1));
          return;
      }

      /*
        lua_State représente un pile (au sens algorithmique du terme)
        qui pourra être manipulée pour interagir avec le code Lua

        Les nombres donné au fonction lua correspondent à leur indice sur la pile
        -1 correspond au haut de la pile
      ,*/

      // Place la table "algorithm_parameters" en haut de la pile
      lua_getglobal(L, "algorithm_parameters");
      // Si la valeur en haut de la pile est bien une table
      if (!lua_istable(L, -1)) {
          luaL_error(L, "algorithm_parameters n'est pas une table ou n'existe pas: %s\n", lua_tostring(L, -1));
          return;
      }

      lua_getfield(L, -1, "BUBBLE_RADIUS");
      // Vérification de type possible...
      double BUBBLE_RADIUS = lua_tonumber(L, -1);
      /* ... lecture des autres paramètres ... */

      /* L'appel de fonctions Lua du fichier .lua est également,
         avec comme paramètres d'entrée et de sortie un objet lua agissant
         sur un tableau C permettant dans Lua l'indiçage, la modification...ect.         
         Mais c'est un peu plus long à écrire et à expliquer */
  }
#+end_src

Le langage Lua a été pensé pour l'interfaçage avec le C (donc le C++)
de cette façon, et LuaJIT en est la version la plus optimisée que je
conaisse. Il faudrait bien sûr tester mais les performances du
langages seraient très bonnes, bien meilleures que n'importe quel
autre langage dynamique. De plus, je connais mieux cette technologie
que l'interfaçage avec du C++ interprété et je serais plus efficace
pour l'utiliser.

Ci-après se trouve un code permettant de lire des tableaux Lua et les
récupérer en C et permettant à un tableau C d'être manipulé par des
fonctions Lua:

#+begin_src C++
  /* Contenu du fichier luaDynamics.lua situé dans le même répertoire

    x = {1.1, 0.9}
    u = {-0.5}

    function dynamics(x, u, image)
        image[1] = x[1]*x[2]
        image[2] = u[1]
    end
  */

  #include <iostream>
  #include "lua/lua.hpp"

  // Classe pour le chargement du fichier lua et pour simplifier l'utilisation des fonction lua
  class UserModel {
  public:
      UserModel(const char *filename) :
          // Initialisation de la pile
          L(luaL_newstate()) {

          // L prend comme valeur "l'état" du programme contenu dans le fichier filename
          // En pratique, Lua empile l'état du programme sur la pile accédée par L
          if (luaL_dofile(L, filename) != LUA_OK) {
              /* Lorsque dofile échoue, le haut de la pile (indicé par -1)
                 contient une chaîne de caractère Lua avec le message d'erreur */
              luaL_error(L, "%s\n", lua_tostring(L, -1));
              exit(1);
          }

          // Création d'une "métatable" de nom doubleMetatableName
          // Ceci est la manière d'implémenter la surcharge d'opérateurs en Lua
          luaL_newmetatable(L, doubleMetatableName);
          static const luaL_Reg arrayFunctions[] = {
              // Lorsque l'on utilise l'opérateur [] en lua sur notre objet,
              // si l'on veut lire la valeur de notre objet, appeler index_DoubleArray
              {"__index", index_DoubleArray},
              // si l'on veut écrire une valeur dans notre objet, appeler assign_DoubleArray
              {"__newindex", assign_DoubleArray},
              // Fin de liste
              {NULL, NULL},
          };
          // On assigne ces fonction à la table en haut de la pile (notre métatable)
          luaL_setfuncs(L, arrayFunctions, 0);
      }

      void getLuaArray(const char *arrayName, double *out, int len) {
          // On récupère le tableau lua en haut de la pile
          lua_getglobal(L, arrayName);
          // On vérifie que c'est un tableau
          luaL_checktype(L, -1, LUA_TTABLE);       

          // On copie le tableau lua dans notre tableau C
          // Tableau Lua indicés à partir de 1
          for (int i = 1; i <= len; ++i) {
              lua_rawgeti(L, -1, i);
              out[i-1] = luaL_checknumber(L, -1);
              lua_pop(L, 1);
          }
      }

      void dynamics(double *x, double *u, double *image) {
          // On met en haut de la pile la fonction de dynamique...
          lua_getglobal(L, "dynamics");
          // ...notre tableau x...
          push_DoubleArray(L, x);
          /// ...notre tableau u...
          push_DoubleArray(L, u);
          // ...et notre tableau image
          push_DoubleArray(L, image);   

          // Et on appelle dynamics(x, u, image) en lua
          /* pcall prend en second argument le nombre de paramètres de la fonction
             supposée en haut de la pile sous ses arguments */
          if (lua_pcall(L, 3, 0, 0) != 0) {
              std::cerr << "Erreur lors de l'appel à dynamics" << std::endl;
              luaL_error(L, "%s\n", lua_tostring(L, -1));
          }    
      }
  private:      
      static int index_DoubleArray(lua_State *L) {
          // On vérifie que l'on a une métatable de nom doubleMetatableName
          // (vérification de type) et on retourne notre tableau si c'est le cas
          double **arrayPtr = (double **) luaL_checkudata(L, 1, doubleMetatableName);
          // On vérifie que l'on a un entier en deuxième position de notre pile
          int index = luaL_checkint(L, 2);
          // On renvoie la valeur d'indice index - 1 de notre tableau C sous-jacent
          // En Lua, la convention veut que l'on indice en partant de 1, mais
          // il est possible d'indicer à partir de 0 en remplaçant index - 1 par index
          lua_pushnumber(L, (*arrayPtr)[index - 1]);
          return 1;
      }

      /* Une affectation à une valeur dans une table lua prend sur la pile
         la forme 1[2] = 3, avec les nombres représentant la position sur la pile */
      static int assign_DoubleArray(lua_State *L) {
          // On vérifie que l'on a une métatable de nom doubleMetatableName
          // (vérification de type) et on retourne notre tableau si c'est le cas
          double **arrayPtr = (double **) luaL_checkudata(L, 1, doubleMetatableName);
          // On vérifie que l'on a un entier en deuxième position de notre pile
          int index = luaL_checkint(L, 2);
          // On vérifie que l'on a une valeur double en 3ème position
          double value = luaL_checknumber(L, 3);
          // On affecte la valeur en position 3 à notre tableau C sous-jacent
          (*arrayPtr)[index - 1] = value;
          return 1;
      }


      static constexpr const char *doubleMetatableName = "doubleArray";
      double **push_DoubleArray(lua_State *L, double *array) {
          // On crée un pointeur sur la pile Lua permettant à Lua d'accéder à notre tableau
          double **arrayLua = (double **) lua_newuserdata(L, sizeof(double *));
          // On affecte à ce tableau en haut de la pile notre métatable de tableau
          // pour permettre les opérations sur le tableau
          luaL_setmetatable(L, doubleMetatableName);
          // On affecte notre tableau à ce pointeur pour que la modification en Lua
          // se traduise par une modification de array
          *arrayLua = array;

          return arrayLua;
      }

      lua_State *L;
  };

  int main()
  {
      double x[2] = {};
      double u[1] = {};
      double image[2] = {};

      // Le fichier luaDynamics.lua peut optionellement être compilé par luaJIT
      UserModel userModel("luaDynamics.lua");

      // Copie dans x et u le contenu des tableaux x et u de lua
      userModel.getLuaArray("x", x, 2);      
      userModel.getLuaArray("u", u, 1);    

      // Applique la dynamique contenue dans le fichier Lua
      userModel.dynamics(x, u, image);
      std::cout << "{" << image[0] << " " << image[1] << "}" << std::endl;

      return 0;
  }
#+end_src

** Déplacement des valeurs constantes dans le code vers des constants globales (dans defs.h)

Par exemple, ~findViableControl_bis~ prend en paramètres le nombre
d'itérations et une valeur indiquant la différence maximale entre le
pas de temps de grille et le pas de temps réel. Ces deux paramètres
devraient être des paramètres globaux car ils sont répétés à plusieurs
endroits dans le code.

** Optimisations des algorithmes de bulles

Les algorithmes de la classe ~Bubble~ sont les algorithmes les plus
longs à l'exécution, dans le cas où la trajectoire est "souvent" loin
du bord et où la bulle ne touche que rarement le noyau.

Il devrait être possible d'améliorer les algorithmes de la bulle (en
réduisant les problèmes d'aliasing par exemple, on utilise en effet
beaucoup de tableaux) mais une idée à creuser serait de laisser à
l'utilisateur la possibilité de choisir son algorithme de bulle parmi:

- Une bulle ne cherchant à savoir si elle touche une frontière du
  noyau de viabilité uniquement sur les points de grilles sur le
  bord de la bulle (idéale si le noyau est convexe et peu coûteuse,
  mais suppose une connaissance sur le noyau)
- Une bulle réalisant un parcours de ses points dans un ordre
  lexicographique sur les coordonées (idéale si le noyau n'est pas
  convexe mais que l'on ne risque "pas souvent" d'être sur le bord du
  noyau, ce parcours étant le plus rapide).
- Une bulle réalisant un parcours de ses points par ordre décroissant
  de distance avec le centre (idéale si le noyau n'est pas convexe
  et que l'on risque souvent de se retrouver proche du bord. En effet,
  dès que l'on trouve un point hors du noyau, la bulle arrête de
  chercher. On suppose que l'on a "plus de chance" de tomber sur un
  point hors du noyau pour une distance au centre plus grande).

** Réflexions sur l'utilisation de VLAs

L'utilisation de VLA (variable length array) qui est faite dans le
code est un sujet assez controversé. De plus, à certains endroits les
VLAs sont utilisées et à d'autres des blocs mémoires classiques
alloués avec ~new~. Je n'ai jamais testé ce qui était le plus
rapide/sûr selon les besoins du code mais il faudrait, pour la
cohérence générale du code, choisir l'un ou l'autre. J'ai moi-même
utilisé les deux.

Le flag ~-Werror=vla~ de gcc/g++ permettrait de détecter les VLAs si
le souhait de les supprimer adviendrait.

** Réflexion sur l'utilisation de la mémoire


Cette réflexion est liée à celle sur l'utilisation de VLAs. Dans le
code il est souvent nécessaire d'allouer des tableaux de ~double~,
d'~int~ ou de ~unsigned long long int~ des mêmes tailles : les
dimensions de l'espace d'état, de contrôles et de tychés. Cette
mémoire pourrait, au lieu d'être allouée le temps d'une
fonction/méthode ou de la durée de vie d'une trajectoire et libérée
juste après, être récupérée de la part d'un objet pouvant gérer la
mémoire. De plus, un tel objet est assez simple à produire si tous les
objets alloués sont de même taille (voir
https://en.wikipedia.org/w/index.php?title=Region-based_memory_management&oldid=1302957973#Implementation
et plus généralement le concept de "memory arena").

Pour des objets de taille relativement petite avec une durée de vie
courte, l'allocation de la mémoire pourrait être source de plus de
ralentissement que le traitement de la donnée elle-même

* Remarques

- Euler sur le modèle de coeur trouve un noyau de viabilité n'incluant
  pas le noyau de viabilité théorique.
